{"version":3,"sources":["node_modules/systemjs/dist/system.src.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,UAAU;AACV;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,8BAA8B;AACjD,kKAAkK;;AAElK;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,qCAAqC;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;;AAEL,+CAA+C;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,qBAAqB,8BAA8B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,4CAA4C;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE;;AAEX;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sCAAsC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA,+BAA+B,IAAI,IAAI;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yCAAyC;AAC3F,OAAO,EAAE;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,0BAA0B;;;AAG1B;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,yEAAyE,iBAAiB;AAC1F;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,+BAA+B,kBAAkB;AAClG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,uDAAuD;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,gBAAgB;AAC7C,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,iBAAiB;AACxC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,wCAAwC;;AAE3E;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,qBAAqB;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,8CAA8C,iDAAiD;;AAErI;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yFAAyF;;AAEzF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA,0BAA0B,GAAG,wDAAwD,qBAAqB,wCAAwC;;AAElJ,qGAAqG,gBAAgB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,wCAAwC,EAAE,aAAa;AAC5E,uPAAuP;;AAEvP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sIAAsI,oCAAoC;;AAE1K;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA,oFAAoF,gBAAgB;AACpG,6EAA6E,aAAa;;AAE1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA,aAAa;AACb,kBAAkB;AAClB,kBAAkB;AAClB,cAAc;AACd,iBAAiB;;AAEjB;;AAEA;AACA,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,uHAAuH,sBAAsB,wBAAwB,EAAE;AACvK;AACA,WAAW;;AAEX;AACA;AACA;AACA,OAAO;AACP;AACA,sHAAsH,0BAA0B;AAChJ;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;AACD","file":"scripts.js","sourcesContent":["/*\n* SystemJS v0.21.6 Dev\n*/\n(function () {\n  'use strict';\n\n  /*\r\n   * Environment\r\n   */\r\n  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\r\n  var isNode = typeof process !== 'undefined' && process.versions && process.versions.node;\r\n  var isWindows = typeof process !== 'undefined' && typeof process.platform === 'string' && process.platform.match(/^win/);\r\n\r\n  var envGlobal = typeof self !== 'undefined' ? self : global;\r\n\r\n  /*\r\n   * Simple Symbol() shim\r\n   */\r\n  var hasSymbol = typeof Symbol !== 'undefined';\r\n  function createSymbol (name) {\r\n    return hasSymbol ? Symbol() : '@@' + name;\r\n  }\r\n\r\n  var toStringTag = hasSymbol && Symbol.toStringTag;\r\n\r\n  /*\r\n   * Environment baseURI\r\n   */\r\n  var baseURI;\r\n\r\n  // environent baseURI detection\r\n  if (typeof document != 'undefined' && document.getElementsByTagName) {\r\n    baseURI = document.baseURI;\r\n\r\n    if (!baseURI) {\r\n      var bases = document.getElementsByTagName('base');\r\n      baseURI = bases[0] && bases[0].href || window.location.href;\r\n    }\r\n  }\r\n  else if (typeof location != 'undefined') {\r\n    baseURI = location.href;\r\n  }\r\n\r\n  // sanitize out the hash and querystring\r\n  if (baseURI) {\r\n    baseURI = baseURI.split('#')[0].split('?')[0];\r\n    var slashIndex = baseURI.lastIndexOf('/');\r\n    if (slashIndex !== -1)\r\n      baseURI = baseURI.substr(0, slashIndex + 1);\r\n  }\r\n  else if (typeof process !== 'undefined' && process.cwd) {\r\n    baseURI = 'file://' + (isWindows ? '/' : '') + process.cwd();\r\n    if (isWindows)\r\n      baseURI = baseURI.replace(/\\\\/g, '/');\r\n  }\r\n  else {\r\n    throw new TypeError('No environment baseURI');\r\n  }\r\n\r\n  // ensure baseURI has trailing \"/\"\r\n  if (baseURI[baseURI.length - 1] !== '/')\r\n    baseURI += '/';\r\n\r\n  /*\r\n   * LoaderError with chaining for loader stacks\r\n   */\r\n  var errArgs = new Error(0, '_').fileName == '_';\r\n  function LoaderError__Check_error_message_for_loader_stack (childErr, newMessage) {\r\n    // Convert file:/// URLs to paths in Node\r\n    if (!isBrowser)\r\n      newMessage = newMessage.replace(isWindows ? /file:\\/\\/\\//g : /file:\\/\\//g, '');\r\n\r\n    var message = (childErr.message || childErr) + '\\n  ' + newMessage;\r\n\r\n    var err;\r\n    if (errArgs && childErr.fileName)\r\n      err = new Error(message, childErr.fileName, childErr.lineNumber);\r\n    else\r\n      err = new Error(message);\r\n\r\n\r\n    var stack = childErr.originalErr ? childErr.originalErr.stack : childErr.stack;\r\n\r\n    if (isNode)\r\n      // node doesn't show the message otherwise\r\n      err.stack = message + '\\n  ' + stack;\r\n    else\r\n      err.stack = stack;\r\n\r\n    err.originalErr = childErr.originalErr || childErr;\r\n\r\n    return err;\r\n  }\n\n  /*\r\n   * Optimized URL normalization assuming a syntax-valid URL parent\r\n   */\r\n  function throwResolveError (relUrl, parentUrl) {\r\n    throw new RangeError('Unable to resolve \"' + relUrl + '\" to ' + parentUrl);\r\n  }\r\n  var backslashRegEx = /\\\\/g;\r\n  function resolveIfNotPlain (relUrl, parentUrl) {\r\n    if (relUrl[0] === ' ' || relUrl[relUrl.length - 1] === ' ')\r\n      relUrl = relUrl.trim();\r\n    var parentProtocol = parentUrl && parentUrl.substr(0, parentUrl.indexOf(':') + 1);\r\n\r\n    var firstChar = relUrl[0];\r\n    var secondChar = relUrl[1];\r\n\r\n    // protocol-relative\r\n    if (firstChar === '/' && secondChar === '/') {\r\n      if (!parentProtocol)\r\n        throwResolveError(relUrl, parentUrl);\r\n      if (relUrl.indexOf('\\\\') !== -1)\r\n        relUrl = relUrl.replace(backslashRegEx, '/');\r\n      return parentProtocol + relUrl;\r\n    }\r\n    // relative-url\r\n    else if (firstChar === '.' && (secondChar === '/' || secondChar === '.' && (relUrl[2] === '/' || relUrl.length === 2 && (relUrl += '/')) ||\r\n        relUrl.length === 1  && (relUrl += '/')) ||\r\n        firstChar === '/') {\r\n      if (relUrl.indexOf('\\\\') !== -1)\r\n        relUrl = relUrl.replace(backslashRegEx, '/');\r\n      var parentIsPlain = !parentProtocol || parentUrl[parentProtocol.length] !== '/';\r\n\r\n      // read pathname from parent if a URL\r\n      // pathname taken to be part after leading \"/\"\r\n      var pathname;\r\n      if (parentIsPlain) {\r\n        // resolving to a plain parent -> skip standard URL prefix, and treat entire parent as pathname\r\n        if (parentUrl === undefined)\r\n          throwResolveError(relUrl, parentUrl);\r\n        pathname = parentUrl;\r\n      }\r\n      else if (parentUrl[parentProtocol.length + 1] === '/') {\r\n        // resolving to a :// so we need to read out the auth and host\r\n        if (parentProtocol !== 'file:') {\r\n          pathname = parentUrl.substr(parentProtocol.length + 2);\r\n          pathname = pathname.substr(pathname.indexOf('/') + 1);\r\n        }\r\n        else {\r\n          pathname = parentUrl.substr(8);\r\n        }\r\n      }\r\n      else {\r\n        // resolving to :/ so pathname is the /... part\r\n        pathname = parentUrl.substr(parentProtocol.length + 1);\r\n      }\r\n\r\n      if (firstChar === '/') {\r\n        if (parentIsPlain)\r\n          throwResolveError(relUrl, parentUrl);\r\n        else\r\n          return parentUrl.substr(0, parentUrl.length - pathname.length - 1) + relUrl;\r\n      }\r\n\r\n      // join together and split for removal of .. and . segments\r\n      // looping the string instead of anything fancy for perf reasons\r\n      // '../../../../../z' resolved to 'x/y' is just 'z' regardless of parentIsPlain\r\n      var segmented = pathname.substr(0, pathname.lastIndexOf('/') + 1) + relUrl;\r\n\r\n      var output = [];\r\n      var segmentIndex = -1;\r\n\r\n      for (var i = 0; i < segmented.length; i++) {\r\n        // busy reading a segment - only terminate on '/'\r\n        if (segmentIndex !== -1) {\r\n          if (segmented[i] === '/') {\r\n            output.push(segmented.substring(segmentIndex, i + 1));\r\n            segmentIndex = -1;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // new segment - check if it is relative\r\n        if (segmented[i] === '.') {\r\n          // ../ segment\r\n          if (segmented[i + 1] === '.' && (segmented[i + 2] === '/' || i + 2 === segmented.length)) {\r\n            output.pop();\r\n            i += 2;\r\n          }\r\n          // ./ segment\r\n          else if (segmented[i + 1] === '/' || i + 1 === segmented.length) {\r\n            i += 1;\r\n          }\r\n          else {\r\n            // the start of a new segment as below\r\n            segmentIndex = i;\r\n            continue;\r\n          }\r\n\r\n          // this is the plain URI backtracking error (../, package:x -> error)\r\n          if (parentIsPlain && output.length === 0)\r\n            throwResolveError(relUrl, parentUrl);\r\n\r\n          continue;\r\n        }\r\n\r\n        // it is the start of a new segment\r\n        segmentIndex = i;\r\n      }\r\n      // finish reading out the last segment\r\n      if (segmentIndex !== -1)\r\n        output.push(segmented.substr(segmentIndex));\r\n\r\n      return parentUrl.substr(0, parentUrl.length - pathname.length) + output.join('');\r\n    }\r\n\r\n    // sanitizes and verifies (by returning undefined if not a valid URL-like form)\r\n    // Windows filepath compatibility is an added convenience here\r\n    var protocolIndex = relUrl.indexOf(':');\r\n    if (protocolIndex !== -1) {\r\n      if (isNode) {\r\n        // C:\\x becomes file:///c:/x (we don't support C|\\x)\r\n        if (relUrl[1] === ':' && relUrl[2] === '\\\\' && relUrl[0].match(/[a-z]/i))\r\n          return 'file:///' + relUrl.replace(backslashRegEx, '/');\r\n      }\r\n      return relUrl;\r\n    }\r\n  }\n\n  var resolvedPromise = Promise.resolve();\r\n\r\n  /*\r\n   * Simple Array values shim\r\n   */\r\n  function arrayValues (arr) {\r\n    if (arr.values)\r\n      return arr.values();\r\n\r\n    if (typeof Symbol === 'undefined' || !Symbol.iterator)\r\n      throw new Error('Symbol.iterator not supported in this browser');\r\n\r\n    var iterable = {};\r\n    iterable[Symbol.iterator] = function () {\r\n      var keys = Object.keys(arr);\r\n      var keyIndex = 0;\r\n      return {\r\n        next: function () {\r\n          if (keyIndex < keys.length)\r\n            return {\r\n              value: arr[keys[keyIndex++]],\r\n              done: false\r\n            };\r\n          else\r\n            return {\r\n              value: undefined,\r\n              done: true\r\n            };\r\n        }\r\n      };\r\n    };\r\n    return iterable;\r\n  }\r\n\r\n  /*\r\n   * 3. Reflect.Loader\r\n   *\r\n   * We skip the entire native internal pipeline, just providing the bare API\r\n   */\r\n  // 3.1.1\r\n  function Loader () {\r\n    this.registry = new Registry();\r\n  }\r\n  // 3.3.1\r\n  Loader.prototype.constructor = Loader;\r\n\r\n  function ensureInstantiated (module) {\r\n    if (module === undefined)\r\n      return;\r\n    if (module instanceof ModuleNamespace === false && module[toStringTag] !== 'module')\r\n      throw new TypeError('Module instantiation did not return a valid namespace object.');\r\n    return module;\r\n  }\r\n\r\n  // 3.3.2\r\n  Loader.prototype.import = function (key, parent) {\r\n    if (typeof key !== 'string')\r\n      throw new TypeError('Loader import method must be passed a module key string');\r\n    // custom resolveInstantiate combined hook for better perf\r\n    var loader = this;\r\n    return resolvedPromise\r\n    .then(function () {\r\n      return loader[RESOLVE_INSTANTIATE](key, parent);\r\n    })\r\n    .then(ensureInstantiated)\r\n    //.then(Module.evaluate)\r\n    .catch(function (err) {\r\n      throw LoaderError__Check_error_message_for_loader_stack(err, 'Loading ' + key + (parent ? ' from ' + parent : ''));\r\n    });\r\n  };\r\n  // 3.3.3\r\n  var RESOLVE = Loader.resolve = createSymbol('resolve');\r\n\r\n  /*\r\n   * Combined resolve / instantiate hook\r\n   *\r\n   * Not in current reduced spec, but necessary to separate RESOLVE from RESOLVE + INSTANTIATE as described\r\n   * in the spec notes of this repo to ensure that loader.resolve doesn't instantiate when not wanted.\r\n   *\r\n   * We implement RESOLVE_INSTANTIATE as a single hook instead of a separate INSTANTIATE in order to avoid\r\n   * the need for double registry lookups as a performance optimization.\r\n   */\r\n  var RESOLVE_INSTANTIATE = Loader.resolveInstantiate = createSymbol('resolveInstantiate');\r\n\r\n  // default resolveInstantiate is just to call resolve and then get from the registry\r\n  // this provides compatibility for the resolveInstantiate optimization\r\n  Loader.prototype[RESOLVE_INSTANTIATE] = function (key, parent) {\r\n    var loader = this;\r\n    return loader.resolve(key, parent)\r\n    .then(function (resolved) {\r\n      return loader.registry.get(resolved);\r\n    });\r\n  };\r\n\r\n  function ensureResolution (resolvedKey) {\r\n    if (resolvedKey === undefined)\r\n      throw new RangeError('No resolution found.');\r\n    return resolvedKey;\r\n  }\r\n\r\n  Loader.prototype.resolve = function (key, parent) {\r\n    var loader = this;\r\n    return resolvedPromise\r\n    .then(function() {\r\n      return loader[RESOLVE](key, parent);\r\n    })\r\n    .then(ensureResolution)\r\n    .catch(function (err) {\r\n      throw LoaderError__Check_error_message_for_loader_stack(err, 'Resolving ' + key + (parent ? ' to ' + parent : ''));\r\n    });\r\n  };\r\n\r\n  // 3.3.4 (import without evaluate)\r\n  // this is not documented because the use of deferred evaluation as in Module.evaluate is not\r\n  // documented, as it is not considered a stable feature to be encouraged\r\n  // Loader.prototype.load may well be deprecated if this stays disabled\r\n  /* Loader.prototype.load = function (key, parent) {\r\n    return Promise.resolve(this[RESOLVE_INSTANTIATE](key, parent || this.key))\r\n    .catch(function (err) {\r\n      throw addToError(err, 'Loading ' + key + (parent ? ' from ' + parent : ''));\r\n    });\r\n  }; */\r\n\r\n  /*\r\n   * 4. Registry\r\n   *\r\n   * Instead of structuring through a Map, just use a dictionary object\r\n   * We throw for construction attempts so this doesn't affect the public API\r\n   *\r\n   * Registry has been adjusted to use Namespace objects over ModuleStatus objects\r\n   * as part of simplifying loader API implementation\r\n   */\r\n  var iteratorSupport = typeof Symbol !== 'undefined' && Symbol.iterator;\r\n  var REGISTRY = createSymbol('registry');\r\n  function Registry() {\r\n    this[REGISTRY] = {};\r\n  }\r\n  // 4.4.1\r\n  if (iteratorSupport) {\r\n    // 4.4.2\r\n    Registry.prototype[Symbol.iterator] = function () {\r\n      return this.entries()[Symbol.iterator]();\r\n    };\r\n\r\n    // 4.4.3\r\n    Registry.prototype.entries = function () {\r\n      var registry = this[REGISTRY];\r\n      return arrayValues(Object.keys(registry).map(function (key) {\r\n        return [key, registry[key]];\r\n      }));\r\n    };\r\n  }\r\n\r\n  // 4.4.4\r\n  Registry.prototype.keys = function () {\r\n    return arrayValues(Object.keys(this[REGISTRY]));\r\n  };\r\n  // 4.4.5\r\n  Registry.prototype.values = function () {\r\n    var registry = this[REGISTRY];\r\n    return arrayValues(Object.keys(registry).map(function (key) {\r\n      return registry[key];\r\n    }));\r\n  };\r\n  // 4.4.6\r\n  Registry.prototype.get = function (key) {\r\n    return this[REGISTRY][key];\r\n  };\r\n  // 4.4.7\r\n  Registry.prototype.set = function (key, namespace) {\r\n    if (!(namespace instanceof ModuleNamespace || namespace[toStringTag] === 'module'))\r\n      throw new Error('Registry must be set with an instance of Module Namespace');\r\n    this[REGISTRY][key] = namespace;\r\n    return this;\r\n  };\r\n  // 4.4.8\r\n  Registry.prototype.has = function (key) {\r\n    return Object.hasOwnProperty.call(this[REGISTRY], key);\r\n  };\r\n  // 4.4.9\r\n  Registry.prototype.delete = function (key) {\r\n    if (Object.hasOwnProperty.call(this[REGISTRY], key)) {\r\n      delete this[REGISTRY][key];\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /*\r\n   * Simple ModuleNamespace Exotic object based on a baseObject\r\n   * We export this for allowing a fast-path for module namespace creation over Module descriptors\r\n   */\r\n  // var EVALUATE = createSymbol('evaluate');\r\n  var BASE_OBJECT = createSymbol('baseObject');\r\n\r\n  // 8.3.1 Reflect.Module\r\n  /*\r\n   * Best-effort simplified non-spec implementation based on\r\n   * a baseObject referenced via getters.\r\n   *\r\n   * Allows:\r\n   *\r\n   *   loader.registry.set('x', new Module({ default: 'x' }));\r\n   *\r\n   * Optional evaluation function provides experimental Module.evaluate\r\n   * support for non-executed modules in registry.\r\n   */\r\n  function ModuleNamespace (baseObject/*, evaluate*/) {\r\n    Object.defineProperty(this, BASE_OBJECT, {\r\n      value: baseObject\r\n    });\r\n\r\n    // evaluate defers namespace population\r\n    /* if (evaluate) {\r\n      Object.defineProperty(this, EVALUATE, {\r\n        value: evaluate,\r\n        configurable: true,\r\n        writable: true\r\n      });\r\n    }\r\n    else { */\r\n      Object.keys(baseObject).forEach(extendNamespace, this);\r\n    //}\r\n  }// 8.4.2\r\n  ModuleNamespace.prototype = Object.create(null);\r\n\r\n  if (toStringTag)\r\n    Object.defineProperty(ModuleNamespace.prototype, toStringTag, {\r\n      value: 'Module'\r\n    });\r\n\r\n  function extendNamespace (key) {\r\n    Object.defineProperty(this, key, {\r\n      enumerable: true,\r\n      get: function () {\r\n        return this[BASE_OBJECT][key];\r\n      }\r\n    });\r\n  }\r\n\r\n  /* function doEvaluate (evaluate, context) {\r\n    try {\r\n      evaluate.call(context);\r\n    }\r\n    catch (e) {\r\n      return e;\r\n    }\r\n  }\r\n\r\n  // 8.4.1 Module.evaluate... not documented or used because this is potentially unstable\r\n  Module.evaluate = function (ns) {\r\n    var evaluate = ns[EVALUATE];\r\n    if (evaluate) {\r\n      ns[EVALUATE] = undefined;\r\n      var err = doEvaluate(evaluate);\r\n      if (err) {\r\n        // cache the error\r\n        ns[EVALUATE] = function () {\r\n          throw err;\r\n        };\r\n        throw err;\r\n      }\r\n      Object.keys(ns[BASE_OBJECT]).forEach(extendNamespace, ns);\r\n    }\r\n    // make chainable\r\n    return ns;\r\n  }; */\n\n  var resolvedPromise$1 = Promise.resolve();\r\n\r\n  /*\r\n   * Register Loader\r\n   *\r\n   * Builds directly on top of loader polyfill to provide:\r\n   * - loader.register support\r\n   * - hookable higher-level resolve\r\n   * - instantiate hook returning a ModuleNamespace or undefined for es module loading\r\n   * - loader error behaviour as in HTML and loader specs, caching load and eval errors separately\r\n   * - build tracing support by providing a .trace=true and .loads object format\r\n   */\r\n\r\n  var REGISTER_INTERNAL = createSymbol('register-internal');\r\n\r\n  function RegisterLoader () {\r\n    Loader.call(this);\r\n\r\n    var registryDelete = this.registry.delete;\r\n    this.registry.delete = function (key) {\r\n      var deleted = registryDelete.call(this, key);\r\n\r\n      // also delete from register registry if linked\r\n      if (records.hasOwnProperty(key) && !records[key].linkRecord) {\r\n        delete records[key];\r\n        deleted = true;\r\n      }\r\n\r\n      return deleted;\r\n    };\r\n\r\n    var records = {};\r\n\r\n    this[REGISTER_INTERNAL] = {\r\n      // last anonymous System.register call\r\n      lastRegister: undefined,\r\n      // in-flight es module load records\r\n      records: records\r\n    };\r\n\r\n    // tracing\r\n    this.trace = false;\r\n  }\r\n\r\n  RegisterLoader.prototype = Object.create(Loader.prototype);\r\n  RegisterLoader.prototype.constructor = RegisterLoader;\r\n\r\n  var INSTANTIATE = RegisterLoader.instantiate = createSymbol('instantiate');\r\n\r\n  // default normalize is the WhatWG style normalizer\r\n  RegisterLoader.prototype[RegisterLoader.resolve = Loader.resolve] = function (key, parentKey) {\r\n    return resolveIfNotPlain(key, parentKey || baseURI);\r\n  };\r\n\r\n  RegisterLoader.prototype[INSTANTIATE] = function (key, processAnonRegister) {};\r\n\r\n  // once evaluated, the linkRecord is set to undefined leaving just the other load record properties\r\n  // this allows tracking new binding listeners for es modules through importerSetters\r\n  // for dynamic modules, the load record is removed entirely.\r\n  function createLoadRecord (state, key, registration) {\r\n    return state.records[key] = {\r\n      key: key,\r\n\r\n      // defined System.register cache\r\n      registration: registration,\r\n\r\n      // module namespace object\r\n      module: undefined,\r\n\r\n      // es-only\r\n      // this sticks around so new module loads can listen to binding changes\r\n      // for already-loaded modules by adding themselves to their importerSetters\r\n      importerSetters: undefined,\r\n\r\n      loadError: undefined,\r\n      evalError: undefined,\r\n\r\n      // in-flight linking record\r\n      linkRecord: {\r\n        // promise for instantiated\r\n        instantiatePromise: undefined,\r\n        dependencies: undefined,\r\n        execute: undefined,\r\n        executingRequire: false,\r\n\r\n        // underlying module object bindings\r\n        moduleObj: undefined,\r\n\r\n        // es only, also indicates if es or not\r\n        setters: undefined,\r\n\r\n        // promise for instantiated dependencies (dependencyInstantiations populated)\r\n        depsInstantiatePromise: undefined,\r\n        // will be the array of dependency load record or a module namespace\r\n        dependencyInstantiations: undefined,\r\n\r\n        // top-level await!\r\n        evaluatePromise: undefined,\r\n\r\n        // NB optimization and way of ensuring module objects in setters\r\n        // indicates setters which should run pre-execution of that dependency\r\n        // setters is then just for completely executed module objects\r\n        // alternatively we just pass the partially filled module objects as\r\n        // arguments into the execute function\r\n        // hoisted: undefined\r\n      }\r\n    };\r\n  }\r\n\r\n  RegisterLoader.prototype[Loader.resolveInstantiate] = function (key, parentKey) {\r\n    var loader = this;\r\n    var state = this[REGISTER_INTERNAL];\r\n    var registry = this.registry[REGISTRY];\r\n\r\n    return resolveInstantiate(loader, key, parentKey, registry, state)\r\n    .then(function (instantiated) {\r\n      if (instantiated instanceof ModuleNamespace || instantiated[toStringTag] === 'module')\r\n        return instantiated;\r\n\r\n      // resolveInstantiate always returns a load record with a link record and no module value\r\n      var link = instantiated.linkRecord;\r\n\r\n      // if already beaten to done, return\r\n      if (!link) {\r\n        if (instantiated.module)\r\n          return instantiated.module;\r\n        throw instantiated.evalError;\r\n      }\r\n\r\n      return deepInstantiateDeps(loader, instantiated, link, registry, state)\r\n      .then(function () {\r\n        return ensureEvaluate(loader, instantiated, link, registry, state);\r\n      });\r\n    });\r\n  };\r\n\r\n  function resolveInstantiate (loader, key, parentKey, registry, state) {\r\n    // normalization shortpath for already-normalized key\r\n    // could add a plain name filter, but doesn't yet seem necessary for perf\r\n    var module = registry[key];\r\n    if (module)\r\n      return Promise.resolve(module);\r\n\r\n    var load = state.records[key];\r\n\r\n    // already linked but not in main registry is ignored\r\n    if (load && !load.module) {\r\n      if (load.loadError)\r\n        return Promise.reject(load.loadError);\r\n      return instantiate(loader, load, load.linkRecord, registry, state);\r\n    }\r\n\r\n    return loader.resolve(key, parentKey)\r\n    .then(function (resolvedKey) {\r\n      // main loader registry always takes preference\r\n      module = registry[resolvedKey];\r\n      if (module)\r\n        return module;\r\n\r\n      load = state.records[resolvedKey];\r\n\r\n      // already has a module value but not already in the registry (load.module)\r\n      // means it was removed by registry.delete, so we should\r\n      // disgard the current load record creating a new one over it\r\n      // but keep any existing registration\r\n      if (!load || load.module)\r\n        load = createLoadRecord(state, resolvedKey, load && load.registration);\r\n\r\n      if (load.loadError)\r\n        return Promise.reject(load.loadError);\r\n\r\n      var link = load.linkRecord;\r\n      if (!link)\r\n        return load;\r\n\r\n      return instantiate(loader, load, link, registry, state);\r\n    });\r\n  }\r\n\r\n  function createProcessAnonRegister (loader, load, state) {\r\n    return function () {\r\n      var lastRegister = state.lastRegister;\r\n\r\n      if (!lastRegister)\r\n        return !!load.registration;\r\n\r\n      state.lastRegister = undefined;\r\n      load.registration = lastRegister;\r\n\r\n      return true;\r\n    };\r\n  }\r\n\r\n  function instantiate (loader, load, link, registry, state) {\r\n    return link.instantiatePromise || (link.instantiatePromise =\r\n    // if there is already an existing registration, skip running instantiate\r\n    (load.registration ? resolvedPromise$1 : resolvedPromise$1.then(function () {\r\n      state.lastRegister = undefined;\r\n      return loader[INSTANTIATE](load.key, loader[INSTANTIATE].length > 1 && createProcessAnonRegister(loader, load, state));\r\n    }))\r\n    .then(function (instantiation) {\r\n      // direct module return from instantiate -> we're done\r\n      if (instantiation !== undefined) {\r\n        if (!(instantiation instanceof ModuleNamespace || instantiation[toStringTag] === 'module'))\r\n          throw new TypeError('Instantiate did not return a valid Module object.');\r\n\r\n        delete state.records[load.key];\r\n        if (loader.trace)\r\n          traceLoad(loader, load, link);\r\n        return registry[load.key] = instantiation;\r\n      }\r\n\r\n      // run the cached loader.register declaration if there is one\r\n      var registration = load.registration;\r\n      // clear to allow new registrations for future loads (combined with registry delete)\r\n      load.registration = undefined;\r\n      if (!registration)\r\n        throw new TypeError('Module instantiation did not call an anonymous or correctly named System.register.');\r\n\r\n      link.dependencies = registration[0];\r\n\r\n      load.importerSetters = [];\r\n\r\n      link.moduleObj = {};\r\n\r\n      // process System.registerDynamic declaration\r\n      if (registration[2]) {\r\n        link.moduleObj.default = link.moduleObj.__useDefault = {};\r\n        link.executingRequire = registration[1];\r\n        link.execute = registration[2];\r\n      }\r\n\r\n      // process System.register declaration\r\n      else {\r\n        registerDeclarative(loader, load, link, registration[1]);\r\n      }\r\n\r\n      return load;\r\n    })\r\n    .catch(function (err) {\r\n      load.linkRecord = undefined;\r\n      throw load.loadError = load.loadError || LoaderError__Check_error_message_for_loader_stack(err, 'Instantiating ' + load.key);\r\n    }));\r\n  }\r\n\r\n  // like resolveInstantiate, but returning load records for linking\r\n  function resolveInstantiateDep (loader, key, parentKey, registry, state, traceDepMap) {\r\n    // normalization shortpaths for already-normalized key\r\n    // DISABLED to prioritise consistent resolver calls\r\n    // could add a plain name filter, but doesn't yet seem necessary for perf\r\n    /* var load = state.records[key];\r\n    var module = registry[key];\r\n\r\n    if (module) {\r\n      if (traceDepMap)\r\n        traceDepMap[key] = key;\r\n\r\n      // registry authority check in case module was deleted or replaced in main registry\r\n      if (load && load.module && load.module === module)\r\n        return load;\r\n      else\r\n        return module;\r\n    }\r\n\r\n    // already linked but not in main registry is ignored\r\n    if (load && !load.module) {\r\n      if (traceDepMap)\r\n        traceDepMap[key] = key;\r\n      return instantiate(loader, load, load.linkRecord, registry, state);\r\n    } */\r\n    return loader.resolve(key, parentKey)\r\n    .then(function (resolvedKey) {\r\n      if (traceDepMap)\r\n        traceDepMap[key] = resolvedKey;\r\n\r\n      // normalization shortpaths for already-normalized key\r\n      var load = state.records[resolvedKey];\r\n      var module = registry[resolvedKey];\r\n\r\n      // main loader registry always takes preference\r\n      if (module && (!load || load.module && module !== load.module))\r\n        return module;\r\n\r\n      if (load && load.loadError)\r\n        throw load.loadError;\r\n\r\n      // already has a module value but not already in the registry (load.module)\r\n      // means it was removed by registry.delete, so we should\r\n      // disgard the current load record creating a new one over it\r\n      // but keep any existing registration\r\n      if (!load || !module && load.module)\r\n        load = createLoadRecord(state, resolvedKey, load && load.registration);\r\n\r\n      var link = load.linkRecord;\r\n      if (!link)\r\n        return load;\r\n\r\n      return instantiate(loader, load, link, registry, state);\r\n    });\r\n  }\r\n\r\n  function traceLoad (loader, load, link) {\r\n    loader.loads = loader.loads || {};\r\n    loader.loads[load.key] = {\r\n      key: load.key,\r\n      deps: link.dependencies,\r\n      dynamicDeps: [],\r\n      depMap: link.depMap || {}\r\n    };\r\n  }\r\n\r\n  /*\r\n   * Convert a CJS module.exports into a valid object for new Module:\r\n   *\r\n   *   new Module(getEsModule(module.exports))\r\n   *\r\n   * Sets the default value to the module, while also reading off named exports carefully.\r\n   */\r\n  function registerDeclarative (loader, load, link, declare) {\r\n    var moduleObj = link.moduleObj;\r\n    var importerSetters = load.importerSetters;\r\n\r\n    var definedExports = false;\r\n\r\n    // closure especially not based on link to allow link record disposal\r\n    var declared = declare.call(envGlobal, function (name, value) {\r\n      if (typeof name === 'object') {\r\n        var changed = false;\r\n        for (var p in name) {\r\n          value = name[p];\r\n          if (p !== '__useDefault' && (!(p in moduleObj) || moduleObj[p] !== value)) {\r\n            changed = true;\r\n            moduleObj[p] = value;\r\n          }\r\n        }\r\n        if (changed === false)\r\n          return value;\r\n      }\r\n      else {\r\n        if ((definedExports || name in moduleObj) && moduleObj[name] === value)\r\n          return value;\r\n        moduleObj[name] = value;\r\n      }\r\n\r\n      for (var i = 0; i < importerSetters.length; i++)\r\n        importerSetters[i](moduleObj);\r\n\r\n      return value;\r\n    }, new ContextualLoader(loader, load.key));\r\n\r\n    link.setters = declared.setters || [];\r\n    link.execute = declared.execute;\r\n    if (declared.exports) {\r\n      link.moduleObj = moduleObj = declared.exports;\r\n      definedExports = true;\r\n    }\r\n  }\r\n\r\n  function instantiateDeps (loader, load, link, registry, state) {\r\n    if (link.depsInstantiatePromise)\r\n      return link.depsInstantiatePromise;\r\n\r\n    var depsInstantiatePromises = Array(link.dependencies.length);\r\n\r\n    for (var i = 0; i < link.dependencies.length; i++)\r\n      depsInstantiatePromises[i] = resolveInstantiateDep(loader, link.dependencies[i], load.key, registry, state, loader.trace && link.depMap || (link.depMap = {}));\r\n\r\n    var depsInstantiatePromise = Promise.all(depsInstantiatePromises)\r\n    .then(function (dependencyInstantiations) {\r\n      link.dependencyInstantiations = dependencyInstantiations;\r\n\r\n      // run setters to set up bindings to instantiated dependencies\r\n      if (link.setters) {\r\n        for (var i = 0; i < dependencyInstantiations.length; i++) {\r\n          var setter = link.setters[i];\r\n          if (setter) {\r\n            var instantiation = dependencyInstantiations[i];\r\n\r\n            if (instantiation instanceof ModuleNamespace || instantiation[toStringTag] === 'module') {\r\n              setter(instantiation);\r\n            }\r\n            else {\r\n              if (instantiation.loadError)\r\n                throw instantiation.loadError;\r\n              setter(instantiation.module || instantiation.linkRecord.moduleObj);\r\n              // this applies to both es and dynamic registrations\r\n              if (instantiation.importerSetters)\r\n                instantiation.importerSetters.push(setter);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return load;\r\n    });\r\n\r\n    if (loader.trace)\r\n      depsInstantiatePromise = depsInstantiatePromise.then(function () {\r\n        traceLoad(loader, load, link);\r\n        return load;\r\n      });\r\n\r\n    depsInstantiatePromise = depsInstantiatePromise.catch(function (err) {\r\n      // throw up the instantiateDeps stack\r\n      link.depsInstantiatePromise = undefined;\r\n      throw LoaderError__Check_error_message_for_loader_stack(err, 'Loading ' + load.key);\r\n    });\r\n\r\n    depsInstantiatePromise.catch(function () {});\r\n\r\n    return link.depsInstantiatePromise = depsInstantiatePromise;\r\n  }\r\n\r\n  function deepInstantiateDeps (loader, load, link, registry, state) {\r\n    var seen = [];\r\n    function addDeps (load, link) {\r\n      if (!link)\r\n        return resolvedPromise$1;\r\n      if (seen.indexOf(load) !== -1)\r\n        return resolvedPromise$1;\r\n      seen.push(load);\r\n      \r\n      return instantiateDeps(loader, load, link, registry, state)\r\n      .then(function () {\r\n        var depPromises;\r\n        for (var i = 0; i < link.dependencies.length; i++) {\r\n          var depLoad = link.dependencyInstantiations[i];\r\n          if (!(depLoad instanceof ModuleNamespace || depLoad[toStringTag] === 'module')) {\r\n            depPromises = depPromises || [];\r\n            depPromises.push(addDeps(depLoad, depLoad.linkRecord));\r\n          }\r\n        }\r\n        if (depPromises)\r\n          return Promise.all(depPromises);\r\n      });\r\n    }\r\n    return addDeps(load, link);\r\n  }\r\n\r\n  /*\r\n   * System.register\r\n   */\r\n  RegisterLoader.prototype.register = function (key, deps, declare) {\r\n    var state = this[REGISTER_INTERNAL];\r\n\r\n    // anonymous modules get stored as lastAnon\r\n    if (declare === undefined) {\r\n      state.lastRegister = [key, deps, undefined];\r\n    }\r\n\r\n    // everything else registers into the register cache\r\n    else {\r\n      var load = state.records[key] || createLoadRecord(state, key, undefined);\r\n      load.registration = [deps, declare, undefined];\r\n    }\r\n  };\r\n\r\n  /*\r\n   * System.registerDyanmic\r\n   */\r\n  RegisterLoader.prototype.registerDynamic = function (key, deps, executingRequire, execute) {\r\n    var state = this[REGISTER_INTERNAL];\r\n\r\n    // anonymous modules get stored as lastAnon\r\n    if (typeof key !== 'string') {\r\n      state.lastRegister = [key, deps, executingRequire];\r\n    }\r\n\r\n    // everything else registers into the register cache\r\n    else {\r\n      var load = state.records[key] || createLoadRecord(state, key, undefined);\r\n      load.registration = [deps, executingRequire, execute];\r\n    }\r\n  };\r\n\r\n  // ContextualLoader class\r\n  // backwards-compatible with previous System.register context argument by exposing .id, .key\r\n  function ContextualLoader (loader, key) {\r\n    this.loader = loader;\r\n    this.key = this.id = key;\r\n    this.meta = {\r\n      url: key\r\n      // scriptElement: null\r\n    };\r\n  }\r\n  /*ContextualLoader.prototype.constructor = function () {\r\n    throw new TypeError('Cannot subclass the contextual loader only Reflect.Loader.');\r\n  };*/\r\n  ContextualLoader.prototype.import = function (key) {\r\n    if (this.loader.trace)\r\n      this.loader.loads[this.key].dynamicDeps.push(key);\r\n    return this.loader.import(key, this.key);\r\n  };\r\n  /*ContextualLoader.prototype.resolve = function (key) {\r\n    return this.loader.resolve(key, this.key);\r\n  };*/\r\n\r\n  function ensureEvaluate (loader, load, link, registry, state) {\r\n    if (load.module)\r\n      return load.module;\r\n    if (load.evalError)\r\n      throw load.evalError;\r\n    if (link.evaluatePromise)\r\n      return link.evaluatePromise;\r\n\r\n    if (link.setters) {\r\n      var evaluatePromise = doEvaluateDeclarative(loader, load, link, registry, state, [load]);\r\n      if (evaluatePromise)\r\n        return evaluatePromise;\r\n    }\r\n    else {\r\n      doEvaluateDynamic(loader, load, link, registry, state, [load]);\r\n    }\r\n    return load.module;\r\n  }\r\n\r\n  function makeDynamicRequire (loader, key, dependencies, dependencyInstantiations, registry, state, seen) {\r\n    // we can only require from already-known dependencies\r\n    return function (name) {\r\n      for (var i = 0; i < dependencies.length; i++) {\r\n        if (dependencies[i] === name) {\r\n          var depLoad = dependencyInstantiations[i];\r\n          var module;\r\n\r\n          if (depLoad instanceof ModuleNamespace || depLoad[toStringTag] === 'module') {\r\n            module = depLoad;\r\n          }\r\n          else {\r\n            if (depLoad.evalError)\r\n              throw depLoad.evalError;\r\n            if (depLoad.module === undefined && seen.indexOf(depLoad) === -1 && !depLoad.linkRecord.evaluatePromise) {\r\n              if (depLoad.linkRecord.setters) {\r\n                doEvaluateDeclarative(loader, depLoad, depLoad.linkRecord, registry, state, [depLoad]);\r\n              }\r\n              else {\r\n                seen.push(depLoad);\r\n                doEvaluateDynamic(loader, depLoad, depLoad.linkRecord, registry, state, seen);\r\n              }\r\n            }\r\n            module = depLoad.module || depLoad.linkRecord.moduleObj;\r\n          }\r\n\r\n          return '__useDefault' in module ? module.__useDefault : module;\r\n        }\r\n      }\r\n      throw new Error('Module ' + name + ' not declared as a System.registerDynamic dependency of ' + key);\r\n    };\r\n  }\r\n\r\n  function evalError (load, err) {\r\n    load.linkRecord = undefined;\r\n    var evalError = LoaderError__Check_error_message_for_loader_stack(err, 'Evaluating ' + load.key);\r\n    if (load.evalError === undefined)\r\n      load.evalError = evalError;\r\n    throw evalError;\r\n  }\r\n\r\n  // es modules evaluate dependencies first\r\n  // returns the error if any\r\n  function doEvaluateDeclarative (loader, load, link, registry, state, seen) {\r\n    var depLoad, depLink;\r\n    var depLoadPromises;\r\n    for (var i = 0; i < link.dependencies.length; i++) {\r\n      var depLoad = link.dependencyInstantiations[i];\r\n      if (depLoad instanceof ModuleNamespace || depLoad[toStringTag] === 'module')\r\n        continue;\r\n\r\n      // custom Module returned from instantiate\r\n      depLink = depLoad.linkRecord;\r\n      if (depLink) {\r\n        if (depLoad.evalError) {\r\n          evalError(load, depLoad.evalError);\r\n        }\r\n        else if (depLink.setters) {\r\n          if (seen.indexOf(depLoad) === -1) {\r\n            seen.push(depLoad);\r\n            try {\r\n              var depLoadPromise = doEvaluateDeclarative(loader, depLoad, depLink, registry, state, seen);\r\n            }\r\n            catch (e) {\r\n              evalError(load, e);\r\n            }\r\n            if (depLoadPromise) {\r\n              depLoadPromises = depLoadPromises || [];\r\n              depLoadPromises.push(depLoadPromise.catch(function (err) {\r\n                evalError(load, err);\r\n              }));\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          try {\r\n            doEvaluateDynamic(loader, depLoad, depLink, registry, state, [depLoad]);\r\n          }\r\n          catch (e) {\r\n            evalError(load, e);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (depLoadPromises)\r\n      return link.evaluatePromise = Promise.all(depLoadPromises)\r\n      .then(function () {\r\n        if (link.execute) {\r\n          // ES System.register execute\r\n          // \"this\" is null in ES\r\n          try {\r\n            var execPromise = link.execute.call(nullContext);\r\n          }\r\n          catch (e) {\r\n            evalError(load, e);\r\n          }\r\n          if (execPromise)\r\n            return execPromise.catch(function (e) {\r\n              evalError(load, e);\r\n            })\r\n            .then(function () {\r\n              load.linkRecord = undefined;\r\n              return registry[load.key] = load.module = new ModuleNamespace(link.moduleObj);\r\n            });\r\n        }\r\n      \r\n        // dispose link record\r\n        load.linkRecord = undefined;\r\n        registry[load.key] = load.module = new ModuleNamespace(link.moduleObj);\r\n      });\r\n\r\n    if (link.execute) {\r\n      // ES System.register execute\r\n      // \"this\" is null in ES\r\n      try {\r\n        var execPromise = link.execute.call(nullContext);\r\n      }\r\n      catch (e) {\r\n        evalError(load, e);\r\n      }\r\n      if (execPromise)\r\n        return link.evaluatePromise = execPromise.catch(function (e) {\r\n          evalError(load, e);\r\n        })\r\n        .then(function () {\r\n          load.linkRecord = undefined;\r\n          return registry[load.key] = load.module = new ModuleNamespace(link.moduleObj);\r\n        });\r\n    }\r\n\r\n    // dispose link record\r\n    load.linkRecord = undefined;\r\n    registry[load.key] = load.module = new ModuleNamespace(link.moduleObj);\r\n  }\r\n\r\n  // non es modules explicitly call moduleEvaluate through require\r\n  function doEvaluateDynamic (loader, load, link, registry, state, seen) {\r\n    // System.registerDynamic execute\r\n    // \"this\" is \"exports\" in CJS\r\n    var module = { id: load.key };\r\n    var moduleObj = link.moduleObj;\r\n    Object.defineProperty(module, 'exports', {\r\n      configurable: true,\r\n      set: function (exports) {\r\n        moduleObj.default = moduleObj.__useDefault = exports;\r\n      },\r\n      get: function () {\r\n        return moduleObj.__useDefault;\r\n      }\r\n    });\r\n\r\n    var require = makeDynamicRequire(loader, load.key, link.dependencies, link.dependencyInstantiations, registry, state, seen);\r\n\r\n    // evaluate deps first\r\n    if (!link.executingRequire)\r\n      for (var i = 0; i < link.dependencies.length; i++)\r\n        require(link.dependencies[i]);\r\n\r\n    try {\r\n      var output = link.execute.call(envGlobal, require, moduleObj.default, module);\r\n      if (output !== undefined)\r\n        module.exports = output;\r\n    }\r\n    catch (e) {\r\n      evalError(load, e);\r\n    }\r\n\r\n    load.linkRecord = undefined;\r\n\r\n    // pick up defineProperty calls to module.exports when we can\r\n    if (module.exports !== moduleObj.__useDefault)\r\n      moduleObj.default = moduleObj.__useDefault = module.exports;\r\n\r\n    var moduleDefault = moduleObj.default;\r\n\r\n    // __esModule flag extension support via lifting\r\n    if (moduleDefault && moduleDefault.__esModule) {\r\n      for (var p in moduleDefault) {\r\n        if (Object.hasOwnProperty.call(moduleDefault, p))\r\n          moduleObj[p] = moduleDefault[p];\r\n      }\r\n    }\r\n\r\n    registry[load.key] = load.module = new ModuleNamespace(link.moduleObj);\r\n\r\n    // run importer setters and clear them\r\n    // this allows dynamic modules to update themselves into es modules\r\n    // as soon as execution has completed\r\n    if (load.importerSetters)\r\n      for (var i = 0; i < load.importerSetters.length; i++)\r\n        load.importerSetters[i](load.module);\r\n    load.importerSetters = undefined;\r\n  }\r\n\r\n  // the closest we can get to call(undefined)\r\n  var nullContext = Object.create(null);\r\n  if (Object.freeze)\r\n    Object.freeze(nullContext);\n\n  var resolvedPromise$2 = Promise.resolve();\n  function noop () {}\n  var emptyModule = new ModuleNamespace({});\n\n  function protectedCreateNamespace (bindings) {\n    if (bindings) {\n      if (bindings instanceof ModuleNamespace || bindings[toStringTag] === 'module')\n        return bindings;\n\n      if (bindings.__esModule)\n        return new ModuleNamespace(bindings);\n    }\n\n    return new ModuleNamespace({ default: bindings, __useDefault: bindings });\n  }\n\n  function isModule (m) {\n    return m instanceof ModuleNamespace || m[toStringTag] === 'module';\n  }\n\n  var CONFIG = createSymbol('loader-config');\n  var METADATA = createSymbol('metadata');\n\n  var isWorker = typeof window === 'undefined' && typeof self !== 'undefined' && typeof importScripts !== 'undefined';\n\n  function warn (msg, force) {\n    if (force || this.warnings && typeof console !== 'undefined' && console.warn)\n      console.warn(msg);\n  }\n\n  function checkInstantiateWasm (loader, wasmBuffer, processAnonRegister) {\n    var bytes = new Uint8Array(wasmBuffer);\n\n    // detect by leading bytes\n    // Can be (new Uint32Array(fetched))[0] === 0x6D736100 when working in Node\n    if (bytes[0] === 0 && bytes[1] === 97 && bytes[2] === 115) {\n      return WebAssembly.compile(wasmBuffer).then(function (m) {\n        var deps = [];\n        var setters = [];\n        var importObj = {};\n\n        // we can only set imports if supported (eg Safari doesnt support)\n        if (WebAssembly.Module.imports)\n          WebAssembly.Module.imports(m).forEach(function (i) {\n            var key = i.module;\n            setters.push(function (m) {\n              importObj[key] = m;\n            });\n            if (deps.indexOf(key) === -1)\n              deps.push(key);\n          });\n        loader.register(deps, function (_export) {\n          return {\n            setters: setters,\n            execute: function () {\n              _export(new WebAssembly.Instance(m, importObj).exports);\n            }\n          };\n        });\n        processAnonRegister();\n\n        return true;\n      });\n    }\n\n    return Promise.resolve(false);\n  }\n\n  var parentModuleContext;\n  function loadNodeModule (key, baseURL) {\n    if (key[0] === '.')\n      throw new Error('Node module ' + key + ' can\\'t be loaded as it is not a package require.');\n\n    if (!parentModuleContext) {\n      var Module = this._nodeRequire('module');\n      var base = decodeURI(baseURL.substr(isWindows ? 8 : 7));\n      parentModuleContext = new Module(base);\n      parentModuleContext.paths = Module._nodeModulePaths(base);\n    }\n    return parentModuleContext.require(key);\n  }\n\n  function extend (a, b) {\n    for (var p in b) {\n      if (!Object.hasOwnProperty.call(b, p))\n        continue;\n      a[p] = b[p];\n    }\n    return a;\n  }\n\n  function prepend (a, b) {\n    for (var p in b) {\n      if (!Object.hasOwnProperty.call(b, p))\n        continue;\n      if (a[p] === undefined)\n        a[p] = b[p];\n    }\n    return a;\n  }\n\n  // meta first-level extends where:\n  // array + array appends\n  // object + object extends\n  // other properties replace\n  function extendMeta (a, b, _prepend) {\n    for (var p in b) {\n      if (!Object.hasOwnProperty.call(b, p))\n        continue;\n      var val = b[p];\n      if (a[p] === undefined)\n        a[p] = val;\n      else if (val instanceof Array && a[p] instanceof Array)\n        a[p] = [].concat(_prepend ? val : a[p]).concat(_prepend ? a[p] : val);\n      else if (typeof val == 'object' && val !== null && typeof a[p] == 'object')\n        a[p] = (_prepend ? prepend : extend)(extend({}, a[p]), val);\n      else if (!_prepend)\n        a[p] = val;\n    }\n  }\n\n  var supportsPreload = false, supportsPrefetch = false;\n  if (isBrowser)\n    (function () {\n      var relList = document.createElement('link').relList;\n      if (relList && relList.supports) {\n        supportsPrefetch = true;\n        try {\n          supportsPreload = relList.supports('preload');\n        }\n        catch (e) {}\n      }\n    })();\n\n  function preloadScript (url) {\n    // fallback to old fashioned image technique which still works in safari\n    if (!supportsPreload && !supportsPrefetch) {\n      var preloadImage = new Image();\n      preloadImage.src = url;\n      return;\n    }\n\n    var link = document.createElement('link');\n    if (supportsPreload) {\n      link.rel = 'preload';\n      link.as = 'script';\n    }\n    else {\n      // this works for all except Safari (detected by relList.supports lacking)\n      link.rel = 'prefetch';\n    }\n    link.href = url;\n    document.head.appendChild(link);\n  }\n\n  function workerImport (src, resolve, reject) {\n    try {\n      importScripts(src);\n    }\n    catch (e) {\n      reject(e);\n    }\n    resolve();\n  }\n\n  if (isBrowser) {\n    var onerror = window.onerror;\n    window.onerror = function globalOnerror (msg, src) {\n      if (onerror)\n        onerror.apply(this, arguments);\n    };\n  }\n\n  function scriptLoad (src, crossOrigin, integrity, resolve, reject) {\n    // percent encode just \"#\" for HTTP requests\n    src = src.replace(/#/g, '%23');\n\n    // subresource integrity is not supported in web workers\n    if (isWorker)\n      return workerImport(src, resolve, reject);\n\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.charset = 'utf-8';\n    script.async = true;\n\n    if (crossOrigin)\n      script.crossOrigin = crossOrigin;\n    if (integrity)\n      script.integrity = integrity;\n\n    script.addEventListener('load', load, false);\n    script.addEventListener('error', error, false);\n\n    script.src = src;\n    document.head.appendChild(script);\n\n    function load () {\n      resolve();\n      cleanup();\n    }\n\n    // note this does not catch execution errors\n    function error (err) {\n      cleanup();\n      reject(new Error('Fetching ' + src));\n    }\n\n    function cleanup () {\n      script.removeEventListener('load', load, false);\n      script.removeEventListener('error', error, false);\n      document.head.removeChild(script);\n    }\n  }\n\n  function readMemberExpression (p, value) {\n    var pParts = p.split('.');\n    while (pParts.length)\n      value = value[pParts.shift()];\n    return value;\n  }\n\n  // separate out paths cache as a baseURL lock process\n  function applyPaths (baseURL, paths, key) {\n    var mapMatch = getMapMatch(paths, key);\n    if (mapMatch) {\n      var target = paths[mapMatch] + key.substr(mapMatch.length);\n\n      var resolved = resolveIfNotPlain(target, baseURI);\n      if (resolved !== undefined)\n        return resolved;\n\n      return baseURL + target;\n    }\n    else if (key.indexOf(':') !== -1) {\n      return key;\n    }\n    else {\n      return baseURL + key;\n    }\n  }\n\n  function checkMap (p) {\n    var name = this.name;\n    // can add ':' here if we want paths to match the behaviour of map\n    if (name.substr(0, p.length) === p && (name.length === p.length || name[p.length] === '/' || p[p.length - 1] === '/' || p[p.length - 1] === ':')) {\n      var curLen = p.split('/').length;\n      if (curLen > this.len) {\n        this.match = p;\n        this.len = curLen;\n      }\n    }\n  }\n\n  function getMapMatch (map, name) {\n    if (Object.hasOwnProperty.call(map, name))\n      return name;\n\n    var bestMatch = {\n      name: name,\n      match: undefined,\n      len: 0\n    };\n\n    Object.keys(map).forEach(checkMap, bestMatch);\n\n    return bestMatch.match;\n  }\n\n  // RegEx adjusted from https://github.com/jbrantly/yabble/blob/master/lib/yabble.js#L339\n  var cjsRequireRegEx = /(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.\"'])require\\s*\\(\\s*(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'|`[^`\\\\]*(?:\\\\.[^`\\\\]*)*`)\\s*\\)/g;\n\n  /*\n   * Source loading\n   */\n  function fetchFetch (url, authorization, integrity, asBuffer) {\n    // fetch doesn't support file:/// urls\n    if (url.substr(0, 8) === 'file:///') {\n      if (hasXhr)\n        return xhrFetch(url, authorization, integrity, asBuffer);\n      else\n        throw new Error('Unable to fetch file URLs in this environment.');\n    }\n\n    // percent encode just \"#\" for HTTP requests\n    url = url.replace(/#/g, '%23');\n\n    var opts = {\n      // NB deprecate\n      headers: { Accept: 'application/x-es-module, */*' }\n    };\n\n    if (integrity)\n      opts.integrity = integrity;\n\n    if (authorization) {\n      if (typeof authorization == 'string')\n        opts.headers['Authorization'] = authorization;\n      opts.credentials = 'include';\n    }\n\n    return fetch(url, opts)\n    .then(function(res) {\n      if (res.ok)\n        return asBuffer ? res.arrayBuffer() : res.text();\n      else\n        throw new Error('Fetch error: ' + res.status + ' ' + res.statusText);\n    });\n  }\n\n  function xhrFetch (url, authorization, integrity, asBuffer) {\n    return new Promise(function (resolve, reject) {\n      // percent encode just \"#\" for HTTP requests\n      url = url.replace(/#/g, '%23');\n\n      var xhr = new XMLHttpRequest();\n      if (asBuffer)\n        xhr.responseType = 'arraybuffer';\n      function load() {\n        resolve(asBuffer ? xhr.response : xhr.responseText);\n      }\n      function error() {\n        reject(new Error('XHR error: ' + (xhr.status ? ' (' + xhr.status + (xhr.statusText ? ' ' + xhr.statusText  : '') + ')' : '') + ' loading ' + url));\n      }\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n          // in Chrome on file:/// URLs, status is 0\n          if (xhr.status == 0) {\n            if (xhr.response) {\n              load();\n            }\n            else {\n              // when responseText is empty, wait for load or error event\n              // to inform if it is a 404 or empty file\n              xhr.addEventListener('error', error);\n              xhr.addEventListener('load', load);\n            }\n          }\n          else if (xhr.status === 200) {\n            load();\n          }\n          else {\n            error();\n          }\n        }\n      };\n      xhr.open(\"GET\", url, true);\n\n      if (xhr.setRequestHeader) {\n        xhr.setRequestHeader('Accept', 'application/x-es-module, */*');\n        // can set \"authorization: true\" to enable withCredentials only\n        if (authorization) {\n          if (typeof authorization == 'string')\n            xhr.setRequestHeader('Authorization', authorization);\n          xhr.withCredentials = true;\n        }\n      }\n\n      xhr.send(null);\n    });\n  }\n\n  var fs;\n  function nodeFetch (url, authorization, integrity, asBuffer) {\n    if (url.substr(0, 8) != 'file:///') {\n      if (hasFetch)\n        return fetchFetch(url, authorization, integrity, asBuffer);\n      else\n        return Promise.reject(new Error('Unable to fetch \"' + url + '\". Only file URLs of the form file:/// supported running in Node without fetch.'));\n    }\n    \n    fs = fs || require('fs');\n    if (isWindows)\n      url = url.replace(/\\//g, '\\\\').substr(8);\n    else\n      url = url.substr(7);\n\n    return new Promise(function (resolve, reject) {\n      fs.readFile(url, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        else {\n          if (asBuffer) {\n            resolve(data);\n          }\n          else {\n            // Strip Byte Order Mark out if it's the leading char\n            var dataString = data + '';\n            if (dataString[0] === '\\ufeff')\n              dataString = dataString.substr(1);\n\n            resolve(dataString);\n          }\n        }\n      });\n    });\n  }\n\n  function noFetch () {\n    throw new Error('No fetch method is defined for this environment.');\n  }\n\n  var fetchFunction;\n\n  var hasXhr = typeof XMLHttpRequest !== 'undefined';\n  var hasFetch = typeof fetch !== 'undefined';\n\n  if (typeof self !== 'undefined' && typeof self.fetch !== 'undefined')\n   fetchFunction = fetchFetch;\n  else if (hasXhr)\n    fetchFunction = xhrFetch;\n  else if (typeof require !== 'undefined' && typeof process !== 'undefined')\n    fetchFunction = nodeFetch;\n  else\n    fetchFunction = noFetch;\n\n  var fetch$1 = fetchFunction;\n\n  function createMetadata () {\n    return {\n      pluginKey: undefined,\n      pluginArgument: undefined,\n      pluginModule: undefined,\n      packageKey: undefined,\n      packageConfig: undefined,\n      load: undefined\n    };\n  }\n\n  function getParentMetadata (loader, config, parentKey) {\n    var parentMetadata = createMetadata();\n\n    if (parentKey) {\n      // detect parent plugin\n      // we just need pluginKey to be truthy for package configurations\n      // so we duplicate it as pluginArgument - although not correct its not used\n      var parentPluginIndex;\n      if (config.pluginFirst) {\n        if ((parentPluginIndex = parentKey.lastIndexOf('!')) !== -1)\n          parentMetadata.pluginArgument = parentMetadata.pluginKey = parentKey.substr(0, parentPluginIndex);\n      }\n      else {\n        if ((parentPluginIndex = parentKey.indexOf('!')) !== -1)\n          parentMetadata.pluginArgument = parentMetadata.pluginKey = parentKey.substr(parentPluginIndex + 1);\n      }\n\n      // detect parent package\n      parentMetadata.packageKey = getMapMatch(config.packages, parentKey);\n      if (parentMetadata.packageKey)\n        parentMetadata.packageConfig = config.packages[parentMetadata.packageKey];\n    }\n\n    return parentMetadata;\n  }\n\n  function normalize (key, parentKey) {\n    var config = this[CONFIG];\n\n    var metadata = createMetadata();\n    var parentMetadata = getParentMetadata(this, config, parentKey);\n\n    var loader = this;\n\n    return Promise.resolve()\n\n    // boolean conditional\n    .then(function () {\n      // first we normalize the conditional\n      var booleanIndex = key.lastIndexOf('#?');\n\n      if (booleanIndex === -1)\n        return Promise.resolve(key);\n\n      var conditionObj = parseCondition.call(loader, key.substr(booleanIndex + 2));\n\n      // in builds, return normalized conditional\n      /*if (this.builder)\n        return this.resolve(conditionObj.module, parentKey)\n        .then(function (conditionModule) {\n          conditionObj.module = conditionModule;\n          return key.substr(0, booleanIndex) + '#?' + serializeCondition(conditionObj);\n        });*/\n\n      return resolveCondition.call(loader, conditionObj, parentKey, true)\n      .then(function (conditionValue) {\n        return conditionValue ? key.substr(0, booleanIndex) : '@empty';\n      });\n    })\n\n    // plugin\n    .then(function (key) {\n      var parsed = parsePlugin(config.pluginFirst, key);\n\n      if (!parsed)\n        return packageResolve.call(loader, config, key, parentMetadata && parentMetadata.pluginArgument || parentKey, metadata, parentMetadata, false);\n\n      metadata.pluginKey = parsed.plugin;\n\n      return Promise.all([\n        packageResolve.call(loader, config, parsed.argument, parentMetadata && parentMetadata.pluginArgument || parentKey, metadata, parentMetadata, true),\n        loader.resolve(parsed.plugin, parentKey)\n      ])\n      .then(function (normalized) {\n        metadata.pluginArgument = normalized[0];\n        metadata.pluginKey = normalized[1];\n\n        // don't allow a plugin to load itself\n        if (metadata.pluginArgument === metadata.pluginKey)\n          throw new Error('Plugin ' + metadata.pluginArgument + ' cannot load itself, make sure it is excluded from any wildcard meta configuration via a custom loader: false rule.');\n\n        return combinePluginParts(config.pluginFirst, normalized[0], normalized[1]);\n      });\n    })\n    .then(function (normalized) {\n      return interpolateConditional.call(loader, normalized, parentKey, parentMetadata);\n    })\n    .then(function (normalized) {\n      setMeta.call(loader, config, normalized, metadata);\n\n      if (metadata.pluginKey || !metadata.load.loader)\n        return normalized;\n\n      // loader by configuration\n      // normalizes to parent to support package loaders\n      return loader.resolve(metadata.load.loader, normalized)\n      .then(function (pluginKey) {\n        metadata.pluginKey = pluginKey;\n        metadata.pluginArgument = normalized;\n        return normalized;\n      });\n    })\n    .then(function (normalized) {\n      loader[METADATA][normalized] = metadata;\n      return normalized;\n    });\n  }\n\n  // normalization function used for registry keys\n  // just does coreResolve without map\n  function decanonicalize (config, key) {\n    var parsed = parsePlugin(config.pluginFirst, key);\n\n    // plugin\n    if (parsed) {\n      var pluginKey = decanonicalize.call(this, config, parsed.plugin);\n      return combinePluginParts(config.pluginFirst, coreResolve.call(this, config, parsed.argument, undefined, false, false), pluginKey);\n    }\n\n    return coreResolve.call(this, config, key, undefined, false, false);\n  }\n\n  function normalizeSync (key, parentKey) {\n    var config = this[CONFIG];\n\n    // normalizeSync is metadataless, so create metadata\n    var metadata = createMetadata();\n    var parentMetadata = parentMetadata || getParentMetadata(this, config, parentKey);\n\n    var parsed = parsePlugin(config.pluginFirst, key);\n\n    // plugin\n    if (parsed) {\n      metadata.pluginKey = normalizeSync.call(this, parsed.plugin, parentKey);\n      return combinePluginParts(config.pluginFirst,\n          packageResolveSync.call(this, config, parsed.argument, parentMetadata.pluginArgument || parentKey, metadata, parentMetadata, !!metadata.pluginKey),\n          metadata.pluginKey);\n    }\n\n    return packageResolveSync.call(this, config, key, parentMetadata.pluginArgument || parentKey, metadata, parentMetadata, !!metadata.pluginKey);\n  }\n\n  function coreResolve (config, key, parentKey, doMap, packageName) {\n    var relativeResolved = resolveIfNotPlain(key, parentKey || baseURI);\n\n    // standard URL resolution\n    if (relativeResolved)\n      return applyPaths(config.baseURL, config.paths, relativeResolved);\n\n    // plain keys not starting with './', 'x://' and '/' go through custom resolution\n    if (doMap) {\n      var mapMatch = getMapMatch(config.map, key);\n\n      if (mapMatch) {\n        key = config.map[mapMatch] + key.substr(mapMatch.length);\n\n        relativeResolved = resolveIfNotPlain(key, baseURI);\n        if (relativeResolved)\n          return applyPaths(config.baseURL, config.paths, relativeResolved);\n      }\n    }\n\n    if (this.registry.has(key))\n      return key;\n\n    if (key.substr(0, 6) === '@node/')\n      return key;\n\n    var trailingSlash = packageName && key[key.length - 1] !== '/';\n    var resolved = applyPaths(config.baseURL, config.paths, trailingSlash ? key + '/' : key);\n    if (trailingSlash)\n      return resolved.substr(0, resolved.length - 1);\n    return resolved;\n  }\n\n  function packageResolveSync (config, key, parentKey, metadata, parentMetadata, skipExtensions) {\n    // ignore . since internal maps handled by standard package resolution\n    if (parentMetadata && parentMetadata.packageConfig && key[0] !== '.') {\n      var parentMap = parentMetadata.packageConfig.map;\n      var parentMapMatch = parentMap && getMapMatch(parentMap, key);\n\n      if (parentMapMatch && typeof parentMap[parentMapMatch] === 'string') {\n        var mapped = doMapSync(this, config, parentMetadata.packageConfig, parentMetadata.packageKey, parentMapMatch, key, metadata, skipExtensions);\n        if (mapped)\n          return mapped;\n      }\n    }\n\n    var normalized = coreResolve.call(this, config, key, parentKey, true, true);\n\n    var pkgConfigMatch = getPackageConfigMatch(config, normalized);\n    metadata.packageKey = pkgConfigMatch && pkgConfigMatch.packageKey || getMapMatch(config.packages, normalized);\n\n    if (!metadata.packageKey)\n      return normalized;\n\n    if (config.packageConfigKeys.indexOf(normalized) !== -1) {\n      metadata.packageKey = undefined;\n      return normalized;\n    }\n\n    metadata.packageConfig = config.packages[metadata.packageKey] || (config.packages[metadata.packageKey] = createPackage());\n\n    var subPath = normalized.substr(metadata.packageKey.length + 1);\n\n    return applyPackageConfigSync(this, config, metadata.packageConfig, metadata.packageKey, subPath, metadata, skipExtensions);\n  }\n\n  function packageResolve (config, key, parentKey, metadata, parentMetadata, skipExtensions) {\n    var loader = this;\n\n    return resolvedPromise$2\n    .then(function () {\n      // ignore . since internal maps handled by standard package resolution\n      if (parentMetadata && parentMetadata.packageConfig && key.substr(0, 2) !== './') {\n        var parentMap = parentMetadata.packageConfig.map;\n        var parentMapMatch = parentMap && getMapMatch(parentMap, key);\n\n        if (parentMapMatch)\n          return doMap(loader, config, parentMetadata.packageConfig, parentMetadata.packageKey, parentMapMatch, key, metadata, skipExtensions);\n      }\n\n      return resolvedPromise$2;\n    })\n    .then(function (mapped) {\n      if (mapped)\n        return mapped;\n\n      // apply map, core, paths, contextual package map\n      var normalized = coreResolve.call(loader, config, key, parentKey, true, true);\n\n      var pkgConfigMatch = getPackageConfigMatch(config, normalized);\n      metadata.packageKey = pkgConfigMatch && pkgConfigMatch.packageKey || getMapMatch(config.packages, normalized);\n\n      if (!metadata.packageKey)\n        return Promise.resolve(normalized);\n\n      if (config.packageConfigKeys.indexOf(normalized) !== -1) {\n        metadata.packageKey = undefined;\n        metadata.load = createMeta();\n        metadata.load.format = 'json';\n        // ensure no loader\n        metadata.load.loader = '';\n        return Promise.resolve(normalized);\n      }\n\n      metadata.packageConfig = config.packages[metadata.packageKey] || (config.packages[metadata.packageKey] = createPackage());\n\n      // load configuration when it matches packageConfigPaths, not already configured, and not the config itself\n      var loadConfig = pkgConfigMatch && !metadata.packageConfig.configured;\n\n      return (loadConfig ? loadPackageConfigPath(loader, config, pkgConfigMatch.configPath, metadata) : resolvedPromise$2)\n      .then(function () {\n        var subPath = normalized.substr(metadata.packageKey.length + 1);\n\n        return applyPackageConfig(loader, config, metadata.packageConfig, metadata.packageKey, subPath, metadata, skipExtensions);\n      });\n    });\n  }\n\n  function createMeta () {\n    return {\n      extension: '',\n      deps: undefined,\n      format: undefined,\n      loader: undefined,\n      scriptLoad: undefined,\n      globals: undefined,\n      nonce: undefined,\n      integrity: undefined,\n      sourceMap: undefined,\n      exports: undefined,\n      encapsulateGlobal: false,\n      crossOrigin: undefined,\n      cjsRequireDetection: true,\n      cjsDeferDepsExecute: false,\n      esModule: false\n    };\n  }\n\n  function setMeta (config, key, metadata) {\n    metadata.load = metadata.load || createMeta();\n\n    // apply wildcard metas\n    var bestDepth = 0;\n    var wildcardIndex;\n    for (var module in config.meta) {\n      wildcardIndex = module.indexOf('*');\n      if (wildcardIndex === -1)\n        continue;\n      if (module.substr(0, wildcardIndex) === key.substr(0, wildcardIndex)\n          && module.substr(wildcardIndex + 1) === key.substr(key.length - module.length + wildcardIndex + 1)) {\n        var depth = module.split('/').length;\n        if (depth > bestDepth)\n          bestDepth = depth;\n        extendMeta(metadata.load, config.meta[module], bestDepth !== depth);\n      }\n    }\n\n    // apply exact meta\n    if (config.meta[key])\n      extendMeta(metadata.load, config.meta[key], false);\n\n    // apply package meta\n    if (metadata.packageKey) {\n      var subPath = key.substr(metadata.packageKey.length + 1);\n\n      var meta = {};\n      if (metadata.packageConfig.meta) {\n        var bestDepth = 0;\n        getMetaMatches(metadata.packageConfig.meta, subPath, function (metaPattern, matchMeta, matchDepth) {\n          if (matchDepth > bestDepth)\n            bestDepth = matchDepth;\n          extendMeta(meta, matchMeta, matchDepth && bestDepth > matchDepth);\n        });\n\n        extendMeta(metadata.load, meta, false);\n      }\n\n      // format\n      if (metadata.packageConfig.format && !metadata.pluginKey && !metadata.load.loader)\n        metadata.load.format = metadata.load.format || metadata.packageConfig.format;\n    }\n  }\n\n  function parsePlugin (pluginFirst, key) {\n    var argumentKey;\n    var pluginKey;\n\n    var pluginIndex = pluginFirst ? key.indexOf('!') : key.lastIndexOf('!');\n\n    if (pluginIndex === -1)\n      return;\n\n    if (pluginFirst) {\n      argumentKey = key.substr(pluginIndex + 1);\n      pluginKey = key.substr(0, pluginIndex);\n    }\n    else {\n      argumentKey = key.substr(0, pluginIndex);\n      pluginKey = key.substr(pluginIndex + 1) || argumentKey.substr(argumentKey.lastIndexOf('.') + 1);\n    }\n\n    return {\n      argument: argumentKey,\n      plugin: pluginKey\n    };\n  }\n\n  // put key back together after parts have been normalized\n  function combinePluginParts (pluginFirst, argumentKey, pluginKey) {\n    if (pluginFirst)\n      return pluginKey + '!' + argumentKey;\n    else\n      return argumentKey + '!' + pluginKey;\n  }\n\n  /*\n   * Package Configuration Extension\n   *\n   * Example:\n   *\n   * SystemJS.packages = {\n   *   jquery: {\n   *     main: 'index.js', // when not set, package key is requested directly\n   *     format: 'amd',\n   *     defaultExtension: 'ts', // defaults to 'js', can be set to false\n   *     modules: {\n   *       '*.ts': {\n   *         loader: 'typescript'\n   *       },\n   *       'vendor/sizzle.js': {\n   *         format: 'global'\n   *       }\n   *     },\n   *     map: {\n   *        // map internal require('sizzle') to local require('./vendor/sizzle')\n   *        sizzle: './vendor/sizzle.js',\n   *        // map any internal or external require of 'jquery/vendor/another' to 'another/index.js'\n   *        './vendor/another.js': './another/index.js',\n   *        // test.js / test -> lib/test.js\n   *        './test.js': './lib/test.js',\n   *\n   *        // environment-specific map configurations\n   *        './index.js': {\n   *          '~browser': './index-node.js',\n   *          './custom-condition.js|~export': './index-custom.js'\n   *        }\n   *     },\n   *     // allows for setting package-prefixed depCache\n   *     // keys are normalized module keys relative to the package itself\n   *     depCache: {\n   *       // import 'package/index.js' loads in parallel package/lib/test.js,package/vendor/sizzle.js\n   *       './index.js': ['./test'],\n   *       './test.js': ['external-dep'],\n   *       'external-dep/path.js': ['./another.js']\n   *     }\n   *   }\n   * };\n   *\n   * Then:\n   *   import 'jquery'                       -> jquery/index.js\n   *   import 'jquery/submodule'             -> jquery/submodule.js\n   *   import 'jquery/submodule.ts'          -> jquery/submodule.ts loaded as typescript\n   *   import 'jquery/vendor/another'        -> another/index.js\n   *\n   * Detailed Behaviours\n   * - main can have a leading \"./\" can be added optionally\n   * - map and defaultExtension are applied to the main\n   * - defaultExtension adds the extension only if the exact extension is not present\n\n   * - if a meta value is available for a module, map and defaultExtension are skipped\n   * - like global map, package map also applies to subpaths (sizzle/x, ./vendor/another/sub)\n   * - condition module map is '@env' module in package or '@system-env' globally\n   * - map targets support conditional interpolation ('./x': './x.#{|env}.js')\n   * - internal package map targets cannot use boolean conditionals\n   *\n   * Package Configuration Loading\n   *\n   * Not all packages may already have their configuration present in the System config\n   * For these cases, a list of packageConfigPaths can be provided, which when matched against\n   * a request, will first request a \".json\" file by the package key to derive the package\n   * configuration from. This allows dynamic loading of non-predetermined code, a key use\n   * case in SystemJS.\n   *\n   * Example:\n   *\n   *   SystemJS.packageConfigPaths = ['packages/test/package.json', 'packages/*.json'];\n   *\n   *   // will first request 'packages/new-package/package.json' for the package config\n   *   // before completing the package request to 'packages/new-package/path'\n   *   SystemJS.import('packages/new-package/path');\n   *\n   *   // will first request 'packages/test/package.json' before the main\n   *   SystemJS.import('packages/test');\n   *\n   * When a package matches packageConfigPaths, it will always send a config request for\n   * the package configuration.\n   * The package key itself is taken to be the match up to and including the last wildcard\n   * or trailing slash.\n   * The most specific package config path will be used.\n   * Any existing package configurations for the package will deeply merge with the\n   * package config, with the existing package configurations taking preference.\n   * To opt-out of the package configuration request for a package that matches\n   * packageConfigPaths, use the { configured: true } package config option.\n   *\n   */\n\n  function addDefaultExtension (config, pkg, pkgKey, subPath, skipExtensions) {\n    // don't apply extensions to folders or if defaultExtension = false\n    if (!subPath || !pkg.defaultExtension || subPath[subPath.length - 1] === '/' || skipExtensions)\n      return subPath;\n\n    var metaMatch = false;\n\n    // exact meta or meta with any content after the last wildcard skips extension\n    if (pkg.meta)\n      getMetaMatches(pkg.meta, subPath, function (metaPattern, matchMeta, matchDepth) {\n        if (matchDepth === 0 || metaPattern.lastIndexOf('*') !== metaPattern.length - 1)\n          return metaMatch = true;\n      });\n\n    // exact global meta or meta with any content after the last wildcard skips extension\n    if (!metaMatch && config.meta)\n      getMetaMatches(config.meta, pkgKey + '/' + subPath, function (metaPattern, matchMeta, matchDepth) {\n        if (matchDepth === 0 || metaPattern.lastIndexOf('*') !== metaPattern.length - 1)\n          return metaMatch = true;\n      });\n\n    if (metaMatch)\n      return subPath;\n\n    // work out what the defaultExtension is and add if not there already\n    var defaultExtension = '.' + pkg.defaultExtension;\n    if (subPath.substr(subPath.length - defaultExtension.length) !== defaultExtension)\n      return subPath + defaultExtension;\n    else\n      return subPath;\n  }\n\n  function applyPackageConfigSync (loader, config, pkg, pkgKey, subPath, metadata, skipExtensions) {\n    // main\n    if (!subPath) {\n      if (pkg.main)\n        subPath = pkg.main.substr(0, 2) === './' ? pkg.main.substr(2) : pkg.main;\n      else\n        // also no submap if key is package itself (import 'pkg' -> 'path/to/pkg.js')\n        // NB can add a default package main convention here\n        // if it becomes internal to the package then it would no longer be an exit path\n        return pkgKey;\n    }\n\n    // map config checking without then with extensions\n    if (pkg.map) {\n      var mapPath = './' + subPath;\n\n      var mapMatch = getMapMatch(pkg.map, mapPath);\n\n      // we then check map with the default extension adding\n      if (!mapMatch) {\n        mapPath = './' + addDefaultExtension(config, pkg, pkgKey, subPath, skipExtensions);\n        if (mapPath !== './' + subPath)\n          mapMatch = getMapMatch(pkg.map, mapPath);\n      }\n      if (mapMatch) {\n        var mapped = doMapSync(loader, config, pkg, pkgKey, mapMatch, mapPath, metadata, skipExtensions);\n        if (mapped)\n          return mapped;\n      }\n    }\n\n    // normal package resolution\n    return pkgKey + '/' + addDefaultExtension(config, pkg, pkgKey, subPath, skipExtensions);\n  }\n\n  function validMapping (mapMatch, mapped, path) {\n    // allow internal ./x -> ./x/y or ./x/ -> ./x/y recursive maps\n    // but only if the path is exactly ./x and not ./x/z\n    if (mapped.substr(0, mapMatch.length) === mapMatch && path.length > mapMatch.length)\n      return false;\n\n    return true;\n  }\n\n  function doMapSync (loader, config, pkg, pkgKey, mapMatch, path, metadata, skipExtensions) {\n    if (path[path.length - 1] === '/')\n      path = path.substr(0, path.length - 1);\n    var mapped = pkg.map[mapMatch];\n\n    if (typeof mapped === 'object')\n      throw new Error('Synchronous conditional normalization not supported sync normalizing ' + mapMatch + ' in ' + pkgKey);\n\n    if (!validMapping(mapMatch, mapped, path) || typeof mapped !== 'string')\n      return;\n\n    return packageResolveSync.call(loader, config, mapped + path.substr(mapMatch.length), pkgKey + '/', metadata, metadata, skipExtensions);\n  }\n\n  function applyPackageConfig (loader, config, pkg, pkgKey, subPath, metadata, skipExtensions) {\n    // main\n    if (!subPath) {\n      if (pkg.main)\n        subPath = pkg.main.substr(0, 2) === './' ? pkg.main.substr(2) : pkg.main;\n      // also no submap if key is package itself (import 'pkg' -> 'path/to/pkg.js')\n      else\n        // NB can add a default package main convention here\n        // if it becomes internal to the package then it would no longer be an exit path\n        return Promise.resolve(pkgKey);\n    }\n\n    // map config checking without then with extensions\n    var mapPath, mapMatch;\n\n    if (pkg.map) {\n      mapPath = './' + subPath;\n      mapMatch = getMapMatch(pkg.map, mapPath);\n\n      // we then check map with the default extension adding\n      if (!mapMatch) {\n        mapPath = './' + addDefaultExtension(config, pkg, pkgKey, subPath, skipExtensions);\n        if (mapPath !== './' + subPath)\n          mapMatch = getMapMatch(pkg.map, mapPath);\n      }\n    }\n\n    return (mapMatch ? doMap(loader, config, pkg, pkgKey, mapMatch, mapPath, metadata, skipExtensions) : resolvedPromise$2)\n    .then(function (mapped) {\n      if (mapped)\n        return Promise.resolve(mapped);\n\n      // normal package resolution / fallback resolution for no conditional match\n      return Promise.resolve(pkgKey + '/' + addDefaultExtension(config, pkg, pkgKey, subPath, skipExtensions));\n    });\n  }\n\n  function doMap (loader, config, pkg, pkgKey, mapMatch, path, metadata, skipExtensions) {\n    if (path[path.length - 1] === '/')\n      path = path.substr(0, path.length - 1);\n\n    var mapped = pkg.map[mapMatch];\n\n    if (typeof mapped === 'string') {\n      if (!validMapping(mapMatch, mapped, path))\n        return resolvedPromise$2;\n      return packageResolve.call(loader, config, mapped + path.substr(mapMatch.length), pkgKey + '/', metadata, metadata, skipExtensions)\n      .then(function (normalized) {\n        return interpolateConditional.call(loader, normalized, pkgKey + '/', metadata);\n      });\n    }\n\n    // we use a special conditional syntax to allow the builder to handle conditional branch points further\n    /*if (loader.builder)\n      return Promise.resolve(pkgKey + '/#:' + path);*/\n\n    // we load all conditions upfront\n    var conditionPromises = [];\n    var conditions = [];\n    for (var e in mapped) {\n      var c = parseCondition(e);\n      conditions.push({\n        condition: c,\n        map: mapped[e]\n      });\n      conditionPromises.push(RegisterLoader.prototype.import.call(loader, c.module, pkgKey));\n    }\n\n    // map object -> conditional map\n    return Promise.all(conditionPromises)\n    .then(function (conditionValues) {\n      // first map condition to match is used\n      for (var i = 0; i < conditions.length; i++) {\n        var c = conditions[i].condition;\n        var value = readMemberExpression(c.prop, '__useDefault' in conditionValues[i] ? conditionValues[i].__useDefault : conditionValues[i]);\n        if (!c.negate && value || c.negate && !value)\n          return conditions[i].map;\n      }\n    })\n    .then(function (mapped) {\n      if (mapped) {\n        if (!validMapping(mapMatch, mapped, path))\n          return resolvedPromise$2;\n        return packageResolve.call(loader, config, mapped + path.substr(mapMatch.length), pkgKey + '/', metadata, metadata, skipExtensions)\n        .then(function (normalized) {\n          return interpolateConditional.call(loader, normalized, pkgKey + '/', metadata);\n        });\n      }\n\n      // no environment match -> fallback to original subPath by returning undefined\n    });\n  }\n\n  // check if the given normalized key matches a packageConfigPath\n  // if so, loads the config\n  var packageConfigPaths = {};\n\n  // data object for quick checks against package paths\n  function createPkgConfigPathObj (path) {\n    var lastWildcard = path.lastIndexOf('*');\n    var length = Math.max(lastWildcard + 1, path.lastIndexOf('/'));\n    return {\n      length: length,\n      regEx: new RegExp('^(' + path.substr(0, length).replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&').replace(/\\*/g, '[^\\\\/]+') + ')(\\\\/|$)'),\n      wildcard: lastWildcard !== -1\n    };\n  }\n\n  // most specific match wins\n  function getPackageConfigMatch (config, normalized) {\n    var pkgKey, exactMatch = false, configPath;\n    for (var i = 0; i < config.packageConfigPaths.length; i++) {\n      var packageConfigPath = config.packageConfigPaths[i];\n      var p = packageConfigPaths[packageConfigPath] || (packageConfigPaths[packageConfigPath] = createPkgConfigPathObj(packageConfigPath));\n      if (normalized.length < p.length)\n        continue;\n      var match = normalized.match(p.regEx);\n      if (match && (!pkgKey || (!(exactMatch && p.wildcard) && pkgKey.length < match[1].length))) {\n        pkgKey = match[1];\n        exactMatch = !p.wildcard;\n        configPath = pkgKey + packageConfigPath.substr(p.length);\n      }\n    }\n\n    if (!pkgKey)\n      return;\n\n    return {\n      packageKey: pkgKey,\n      configPath: configPath\n    };\n  }\n\n  function loadPackageConfigPath (loader, config, pkgConfigPath, metadata, normalized) {\n    var configLoader = loader.pluginLoader || loader;\n\n    // ensure we note this is a package config file path\n    // it will then be skipped from getting other normalizations itself to ensure idempotency\n    if (config.packageConfigKeys.indexOf(pkgConfigPath) === -1)\n      config.packageConfigKeys.push(pkgConfigPath);\n\n    return configLoader.import(pkgConfigPath)\n    .then(function (pkgConfig) {\n      setPkgConfig(metadata.packageConfig, pkgConfig, metadata.packageKey, true, config);\n      metadata.packageConfig.configured = true;\n    })\n    .catch(function (err) {\n      throw LoaderError__Check_error_message_for_loader_stack(err, 'Unable to fetch package configuration file ' + pkgConfigPath);\n    });\n  }\n\n  function getMetaMatches (pkgMeta, subPath, matchFn) {\n    // wildcard meta\n    var wildcardIndex;\n    for (var module in pkgMeta) {\n      // allow meta to start with ./ for flexibility\n      var dotRel = module.substr(0, 2) === './' ? './' : '';\n      if (dotRel)\n        module = module.substr(2);\n\n      wildcardIndex = module.indexOf('*');\n      if (wildcardIndex === -1)\n        continue;\n\n      if (module.substr(0, wildcardIndex) === subPath.substr(0, wildcardIndex)\n          && module.substr(wildcardIndex + 1) === subPath.substr(subPath.length - module.length + wildcardIndex + 1)) {\n        // alow match function to return true for an exit path\n        if (matchFn(module, pkgMeta[dotRel + module], module.split('/').length))\n          return;\n      }\n    }\n    // exact meta\n    var exactMeta = pkgMeta[subPath] && Object.hasOwnProperty.call(pkgMeta, subPath) ? pkgMeta[subPath] : pkgMeta['./' + subPath];\n    if (exactMeta)\n      matchFn(exactMeta, exactMeta, 0);\n  }\n\n\n  /*\n   * Conditions Extension\n   *\n   *   Allows a condition module to alter the resolution of an import via syntax:\n   *\n   *     import $ from 'jquery/#{browser}';\n   *\n   *   Will first load the module 'browser' via `SystemJS.import('browser')` and\n   *   take the default export of that module.\n   *   If the default export is not a string, an error is thrown.\n   *\n   *   We then substitute the string into the require to get the conditional resolution\n   *   enabling environment-specific variations like:\n   *\n   *     import $ from 'jquery/ie'\n   *     import $ from 'jquery/firefox'\n   *     import $ from 'jquery/chrome'\n   *     import $ from 'jquery/safari'\n   *\n   *   It can be useful for a condition module to define multiple conditions.\n   *   This can be done via the `|` modifier to specify an export member expression:\n   *\n   *     import 'jquery/#{./browser.js|grade.version}'\n   *\n   *   Where the `grade` export `version` member in the `browser.js` module  is substituted.\n   *\n   *\n   * Boolean Conditionals\n   *\n   *   For polyfill modules, that are used as imports but have no module value,\n   *   a binary conditional allows a module not to be loaded at all if not needed:\n   *\n   *     import 'es5-shim#?./conditions.js|needs-es5shim'\n   *\n   *   These conditions can also be negated via:\n   *\n   *     import 'es5-shim#?./conditions.js|~es6'\n   *\n   */\n\n  var sysConditions = ['browser', 'node', 'dev', 'build', 'production', 'default'];\n\n  function parseCondition (condition) {\n    var conditionExport, conditionModule, negation;\n\n    var negation;\n    var conditionExportIndex = condition.lastIndexOf('|');\n    if (conditionExportIndex !== -1) {\n      conditionExport = condition.substr(conditionExportIndex + 1);\n      conditionModule = condition.substr(0, conditionExportIndex);\n\n      if (conditionExport[0] === '~') {\n        negation = true;\n        conditionExport = conditionExport.substr(1);\n      }\n    }\n    else {\n      negation = condition[0] === '~';\n      conditionExport = 'default';\n      conditionModule = condition.substr(negation);\n      if (sysConditions.indexOf(conditionModule) !== -1) {\n        conditionExport = conditionModule;\n        conditionModule = null;\n      }\n    }\n\n    return {\n      module: conditionModule || '@system-env',\n      prop: conditionExport,\n      negate: negation\n    };\n  }\n\n  function resolveCondition (conditionObj, parentKey, bool) {\n    // import without __useDefault handling here\n    return RegisterLoader.prototype.import.call(this, conditionObj.module, parentKey)\n    .then(function (condition) {\n      var m = readMemberExpression(conditionObj.prop, condition);\n\n      if (bool && typeof m !== 'boolean')\n        throw new TypeError('Condition did not resolve to a boolean.');\n\n      return conditionObj.negate ? !m : m;\n    });\n  }\n\n  var interpolationRegEx = /#\\{[^\\}]+\\}/;\n  function interpolateConditional (key, parentKey, parentMetadata) {\n    // first we normalize the conditional\n    var conditionalMatch = key.match(interpolationRegEx);\n\n    if (!conditionalMatch)\n      return Promise.resolve(key);\n\n    var conditionObj = parseCondition.call(this, conditionalMatch[0].substr(2, conditionalMatch[0].length - 3));\n\n    // in builds, return normalized conditional\n    /*if (this.builder)\n      return this.normalize(conditionObj.module, parentKey, createMetadata(), parentMetadata)\n      .then(function (conditionModule) {\n        conditionObj.module = conditionModule;\n        return key.replace(interpolationRegEx, '#{' + serializeCondition(conditionObj) + '}');\n      });*/\n\n    return resolveCondition.call(this, conditionObj, parentKey, false)\n    .then(function (conditionValue) {\n      if (typeof conditionValue !== 'string')\n        throw new TypeError('The condition value for ' + key + ' doesn\\'t resolve to a string.');\n\n      if (conditionValue.indexOf('/') !== -1)\n        throw new TypeError('Unabled to interpolate conditional ' + key + (parentKey ? ' in ' + parentKey : '') + '\\n\\tThe condition value ' + conditionValue + ' cannot contain a \"/\" separator.');\n\n      return key.replace(interpolationRegEx, conditionValue);\n    });\n  }\n\n  /*\n   Extend config merging one deep only\n\n    loader.config({\n      some: 'random',\n      config: 'here',\n      deep: {\n        config: { too: 'too' }\n      }\n    });\n\n    <=>\n\n    loader.some = 'random';\n    loader.config = 'here'\n    loader.deep = loader.deep || {};\n    loader.deep.config = { too: 'too' };\n\n\n    Normalizes meta and package configs allowing for:\n\n    SystemJS.config({\n      meta: {\n        './index.js': {}\n      }\n    });\n\n    To become\n\n    SystemJS.meta['https://thissite.com/index.js'] = {};\n\n    For easy normalization canonicalization with latest URL support.\n\n  */\n  var envConfigNames = ['browserConfig', 'nodeConfig', 'devConfig', 'buildConfig', 'productionConfig'];\n  function envSet(loader, cfg, envCallback) {\n    for (var i = 0; i < envConfigNames.length; i++) {\n      var envConfig = envConfigNames[i];\n      if (cfg[envConfig] && envModule[envConfig.substr(0, envConfig.length - 6)])\n        envCallback(cfg[envConfig]);\n    }\n  }\n\n  function cloneObj (obj, maxDepth) {\n    var clone = {};\n    for (var p in obj) {\n      var prop = obj[p];\n      if (maxDepth > 1) {\n        if (prop instanceof Array)\n          clone[p] = [].concat(prop);\n        else if (typeof prop === 'object')\n          clone[p] = cloneObj(prop, maxDepth - 1);\n        else if (p !== 'packageConfig')\n          clone[p] = prop;\n      }\n      else {\n        clone[p] = prop;\n      }\n    }\n    return clone;\n  }\n\n  function getConfigItem (config, p) {\n    var cfgItem = config[p];\n\n    // getConfig must return an unmodifiable clone of the configuration\n    if (cfgItem instanceof Array)\n      return config[p].concat([]);\n    else if (typeof cfgItem === 'object')\n      return cloneObj(cfgItem, 3)\n    else\n      return config[p];\n  }\n\n  function getConfig (configName) {\n    if (configName) {\n      if (configNames.indexOf(configName) !== -1)\n        return getConfigItem(this[CONFIG], configName);\n      throw new Error('\"' + configName + '\" is not a valid configuration name. Must be one of ' + configNames.join(', ') + '.');\n    }\n\n    var cfg = {};\n    for (var i = 0; i < configNames.length; i++) {\n      var p = configNames[i];\n      var configItem = getConfigItem(this[CONFIG], p);\n      if (configItem !== undefined)\n        cfg[p] = configItem;\n    }\n    return cfg;\n  }\n\n  function setConfig (cfg, isEnvConfig) {\n    var loader = this;\n    var config = this[CONFIG];\n\n    if ('warnings' in cfg)\n      config.warnings = cfg.warnings;\n\n    if ('wasm' in cfg)\n      config.wasm = typeof WebAssembly !== 'undefined' && cfg.wasm;\n\n    if ('production' in cfg || 'build' in cfg)\n      setProduction.call(loader, !!cfg.production, !!(cfg.build || envModule && envModule.build));\n\n    if (!isEnvConfig) {\n      // if using nodeConfig / browserConfig / productionConfig, take baseURL from there\n      // these exceptions will be unnecessary when we can properly implement config queuings\n      var baseURL;\n      envSet(loader, cfg, function(cfg) {\n        baseURL = baseURL || cfg.baseURL;\n      });\n      baseURL = baseURL || cfg.baseURL;\n\n      // always configure baseURL first\n      if (baseURL) {\n        config.baseURL = resolveIfNotPlain(baseURL, baseURI) || resolveIfNotPlain('./' + baseURL, baseURI);\n        if (config.baseURL[config.baseURL.length - 1] !== '/')\n          config.baseURL += '/';\n      }\n\n      if (cfg.paths)\n        extend(config.paths, cfg.paths);\n\n      envSet(loader, cfg, function(cfg) {\n        if (cfg.paths)\n          extend(config.paths, cfg.paths);\n      });\n\n      for (var p in config.paths) {\n        if (config.paths[p].indexOf('*') === -1)\n          continue;\n        warn.call(config, 'Path config ' + p + ' -> ' + config.paths[p] + ' is no longer supported as wildcards are deprecated.');\n        delete config.paths[p];\n      }\n    }\n\n    if (cfg.defaultJSExtensions)\n      warn.call(config, 'The defaultJSExtensions configuration option is deprecated.\\n  Use packages defaultExtension instead.', true);\n\n    if (typeof cfg.pluginFirst === 'boolean')\n      config.pluginFirst = cfg.pluginFirst;\n\n    if (cfg.map) {\n      for (var p in cfg.map) {\n        var v = cfg.map[p];\n\n        if (typeof v === 'string') {\n          var mapped = coreResolve.call(loader, config, v, undefined, false, false);\n          if (mapped[mapped.length -1] === '/' && p[p.length - 1] !== ':' && p[p.length - 1] !== '/')\n            mapped = mapped.substr(0, mapped.length - 1);\n          config.map[p] = mapped;\n        }\n\n        // object map\n        else {\n          var pkgName = coreResolve.call(loader, config, p[p.length - 1] !== '/' ? p + '/' : p, undefined, true, true);\n          pkgName = pkgName.substr(0, pkgName.length - 1);\n\n          var pkg = config.packages[pkgName];\n          if (!pkg) {\n            pkg = config.packages[pkgName] = createPackage();\n            // use '' instead of false to keep type consistent\n            pkg.defaultExtension = '';\n          }\n          setPkgConfig(pkg, { map: v }, pkgName, false, config);\n        }\n      }\n    }\n\n    if (cfg.packageConfigPaths) {\n      var packageConfigPaths = [];\n      for (var i = 0; i < cfg.packageConfigPaths.length; i++) {\n        var path = cfg.packageConfigPaths[i];\n        var packageLength = Math.max(path.lastIndexOf('*') + 1, path.lastIndexOf('/'));\n        var normalized = coreResolve.call(loader, config, path.substr(0, packageLength), undefined, false, false);\n        packageConfigPaths[i] = normalized + path.substr(packageLength);\n      }\n      config.packageConfigPaths = packageConfigPaths;\n    }\n\n    if (cfg.bundles) {\n      for (var p in cfg.bundles) {\n        var bundle = [];\n        for (var i = 0; i < cfg.bundles[p].length; i++)\n          bundle.push(loader.normalizeSync(cfg.bundles[p][i]));\n        config.bundles[p] = bundle;\n      }\n    }\n\n    if (cfg.packages) {\n      for (var p in cfg.packages) {\n        if (p.match(/^([^\\/]+:)?\\/\\/$/))\n          throw new TypeError('\"' + p + '\" is not a valid package name.');\n\n        var pkgName = coreResolve.call(loader, config, p[p.length - 1] !== '/' ? p + '/' : p, undefined, true, true);\n        pkgName = pkgName.substr(0, pkgName.length - 1);\n\n        setPkgConfig(config.packages[pkgName] = config.packages[pkgName] || createPackage(), cfg.packages[p], pkgName, false, config);\n      }\n    }\n\n    if (cfg.depCache) {\n      for (var p in cfg.depCache)\n        config.depCache[loader.normalizeSync(p)] = [].concat(cfg.depCache[p]);\n    }\n\n    if (cfg.meta) {\n      for (var p in cfg.meta) {\n        // base wildcard stays base\n        if (p[0] === '*') {\n          extend(config.meta[p] = config.meta[p] || {}, cfg.meta[p]);\n        }\n        else {\n          var resolved = coreResolve.call(loader, config, p, undefined, true, true);\n          extend(config.meta[resolved] = config.meta[resolved] || {}, cfg.meta[p]);\n        }\n      }\n    }\n\n    if ('transpiler' in cfg)\n      config.transpiler = cfg.transpiler;\n\n\n    // copy any remaining non-standard configuration properties\n    for (var c in cfg) {\n      if (configNames.indexOf(c) !== -1)\n        continue;\n      if (envConfigNames.indexOf(c) !== -1)\n        continue;\n\n      // warn.call(config, 'Setting custom config option `System.config({ ' + c + ': ... })` is deprecated. Avoid custom config options or set SystemJS.' + c + ' = ... directly.');\n      loader[c] = cfg[c];\n    }\n\n    envSet(loader, cfg, function(cfg) {\n      loader.config(cfg, true);\n    });\n  }\n\n  function createPackage () {\n    return {\n      defaultExtension: undefined,\n      main: undefined,\n      format: undefined,\n      meta: undefined,\n      map: undefined,\n      packageConfig: undefined,\n      configured: false\n    };\n  }\n\n  // deeply-merge (to first level) config with any existing package config\n  function setPkgConfig (pkg, cfg, pkgName, prependConfig, config) {\n    for (var prop in cfg) {\n      if (prop === 'main' || prop === 'format' || prop === 'defaultExtension' || prop === 'configured') {\n        if (!prependConfig || pkg[prop] === undefined)\n          pkg[prop] = cfg[prop];\n      }\n      else if (prop === 'map') {\n        (prependConfig ? prepend : extend)(pkg.map = pkg.map || {}, cfg.map);\n      }\n      else if (prop === 'meta') {\n        (prependConfig ? prepend : extend)(pkg.meta = pkg.meta || {}, cfg.meta);\n      }\n      else if (Object.hasOwnProperty.call(cfg, prop)) {\n        warn.call(config, '\"' + prop + '\" is not a valid package configuration option in package ' + pkgName);\n      }\n    }\n\n    // default defaultExtension for packages only\n    if (pkg.defaultExtension === undefined)\n      pkg.defaultExtension = 'js';\n\n    if (pkg.main === undefined && pkg.map && pkg.map['.']) {\n      pkg.main = pkg.map['.'];\n      delete pkg.map['.'];\n    }\n    // main object becomes main map\n    else if (typeof pkg.main === 'object') {\n      pkg.map = pkg.map || {};\n      pkg.map['./@main'] = pkg.main;\n      pkg.main['default'] = pkg.main['default'] || './';\n      pkg.main = '@main';\n    }\n\n    return pkg;\n  }\n\n  var hasBuffer = typeof Buffer !== 'undefined';\n  try {\n    if (hasBuffer && new Buffer('a').toString('base64') !== 'YQ==')\n      hasBuffer = false;\n  }\n  catch (e) {\n    hasBuffer = false;\n  }\n\n  var sourceMapPrefix = '\\n//# sourceMapping' + 'URL=data:application/json;base64,';\n  function inlineSourceMap (sourceMapString) {\n    if (hasBuffer)\n      return sourceMapPrefix + new Buffer(sourceMapString).toString('base64');\n    else if (typeof btoa !== 'undefined')\n      return sourceMapPrefix + btoa(unescape(encodeURIComponent(sourceMapString)));\n    else\n      return '';\n  }\n\n  function getSource(source, sourceMap, address, wrap) {\n    var lastLineIndex = source.lastIndexOf('\\n');\n\n    if (sourceMap) {\n      if (typeof sourceMap != 'object')\n        throw new TypeError('load.metadata.sourceMap must be set to an object.');\n\n      sourceMap = JSON.stringify(sourceMap);\n    }\n\n    return (wrap ? '(function(System, SystemJS) {' : '') + source + (wrap ? '\\n})(System, System);' : '')\n        // adds the sourceURL comment if not already present\n        + (source.substr(lastLineIndex, 15) != '\\n//# sourceURL='\n          ? '\\n//# sourceURL=' + address + (sourceMap ? '!transpiled' : '') : '')\n        // add sourceMappingURL if load.metadata.sourceMap is set\n        + (sourceMap && inlineSourceMap(sourceMap) || '');\n  }\n\n  // script execution via injecting a script tag into the page\n  // this allows CSP nonce to be set for CSP environments\n  var head;\n  function scriptExec(loader, source, sourceMap, address, nonce) {\n    if (!head)\n      head = document.head || document.body || document.documentElement;\n\n    var script = document.createElement('script');\n    script.text = getSource(source, sourceMap, address, false);\n    var onerror = window.onerror;\n    var e;\n    window.onerror = function(_e) {\n      e = addToError(_e, 'Evaluating ' + address);\n      if (onerror)\n        onerror.apply(this, arguments);\n    };\n    preExec(loader);\n\n    if (nonce)\n      script.setAttribute('nonce', nonce);\n\n    head.appendChild(script);\n    head.removeChild(script);\n    postExec();\n    window.onerror = onerror;\n    if (e)\n      return e;\n  }\n\n  var vm;\n  var useVm;\n\n  var curSystem;\n\n  var callCounter = 0;\n  function preExec (loader) {\n    if (callCounter++ == 0)\n      curSystem = envGlobal.System;\n    envGlobal.System = envGlobal.SystemJS = loader;\n  }\n  function postExec () {\n    if (--callCounter == 0)\n      envGlobal.System = envGlobal.SystemJS = curSystem;\n  }\n\n  var supportsScriptExec = false;\n  if (isBrowser && typeof document != 'undefined' && document.getElementsByTagName) {\n    if (!(window.chrome && window.chrome.extension || navigator.userAgent.match(/^Node\\.js/)))\n      supportsScriptExec = true;\n  }\n\n  function evaluate (loader, source, sourceMap, address, integrity, nonce, noWrap) {\n    if (!source)\n      return;\n    if (nonce && supportsScriptExec)\n      return scriptExec(loader, source, sourceMap, address, nonce);\n    try {\n      preExec(loader);\n      // global scoped eval for node (avoids require scope leak)\n      if (!vm && loader._nodeRequire) {\n        vm = loader._nodeRequire('vm');\n        useVm = vm.runInThisContext(\"typeof System !== 'undefined' && System\") === loader;\n      }\n      if (useVm)\n        vm.runInThisContext(getSource(source, sourceMap, address, !noWrap), { filename: address + (sourceMap ? '!transpiled' : '') });\n      else\n        (0, eval)(getSource(source, sourceMap, address, !noWrap));\n      postExec();\n    }\n    catch (e) {\n      postExec();\n      return e;\n    }\n  }\n\n  function setHelpers (loader) {\n    loader.set('@@cjs-helpers', loader.newModule({\n      requireResolve: requireResolve.bind(loader),\n      getPathVars: getPathVars\n    }));\n\n    loader.set('@@global-helpers', loader.newModule({\n      prepareGlobal: prepareGlobal\n    }));\n  }\n\n  function setAmdHelper (loader) {\n\n    /*\n      AMD-compatible require\n      To copy RequireJS, set window.require = window.requirejs = loader.amdRequire\n    */\n    function require (names, callback, errback, referer) {\n      // in amd, first arg can be a config object... we just ignore\n      if (typeof names === 'object' && !(names instanceof Array))\n        return require.apply(null, Array.prototype.splice.call(arguments, 1, arguments.length - 1));\n\n      // amd require\n      if (typeof names === 'string' && typeof callback === 'function')\n        names = [names];\n      if (names instanceof Array) {\n        var dynamicRequires = [];\n        for (var i = 0; i < names.length; i++)\n          dynamicRequires.push(loader.import(names[i], referer));\n        Promise.all(dynamicRequires).then(function (modules) {\n          if (callback)\n            callback.apply(null, modules);\n        }, errback);\n      }\n\n      // commonjs require\n      else if (typeof names === 'string') {\n        var normalized = loader.decanonicalize(names, referer);\n        var module = loader.get(normalized);\n        if (!module)\n          throw new Error('Module not already loaded loading \"' + names + '\" as ' + normalized + (referer ? ' from \"' + referer + '\".' : '.'));\n        return '__useDefault' in module ? module.__useDefault : module;\n      }\n\n      else\n        throw new TypeError('Invalid require');\n    }\n\n    function define (name, deps, factory) {\n      if (typeof name !== 'string') {\n        factory = deps;\n        deps = name;\n        name = null;\n      }\n\n      if (!(deps instanceof Array)) {\n        factory = deps;\n        deps = ['require', 'exports', 'module'].splice(0, factory.length);\n      }\n\n      if (typeof factory !== 'function')\n        factory = (function (factory) {\n          return function() { return factory; }\n        })(factory);\n\n      if (!name) {\n        if (curMetaDeps) {\n          deps = deps.concat(curMetaDeps);\n          curMetaDeps = undefined;\n        }\n      }\n\n      // remove system dependencies\n      var requireIndex, exportsIndex, moduleIndex;\n\n      if ((requireIndex = deps.indexOf('require')) !== -1) {\n\n        deps.splice(requireIndex, 1);\n\n        // only trace cjs requires for non-named\n        // named defines assume the trace has already been done\n        if (!name)\n          deps = deps.concat(amdGetCJSDeps(factory.toString(), requireIndex));\n      }\n\n      if ((exportsIndex = deps.indexOf('exports')) !== -1)\n        deps.splice(exportsIndex, 1);\n\n      if ((moduleIndex = deps.indexOf('module')) !== -1)\n        deps.splice(moduleIndex, 1);\n\n      function execute (req, exports, module) {\n        var depValues = [];\n        for (var i = 0; i < deps.length; i++)\n          depValues.push(req(deps[i]));\n\n        module.uri = module.id;\n\n        module.config = noop;\n\n        // add back in system dependencies\n        if (moduleIndex !== -1)\n          depValues.splice(moduleIndex, 0, module);\n\n        if (exportsIndex !== -1)\n          depValues.splice(exportsIndex, 0, exports);\n\n        if (requireIndex !== -1) {\n          var contextualRequire = function (names, callback, errback) {\n            if (typeof names === 'string' && typeof callback !== 'function')\n              return req(names);\n            return require.call(loader, names, callback, errback, module.id);\n          };\n          contextualRequire.toUrl = function (name) {\n            return loader.normalizeSync(name, module.id);\n          };\n          depValues.splice(requireIndex, 0, contextualRequire);\n        }\n\n        // set global require to AMD require\n        var curRequire = envGlobal.require;\n        envGlobal.require = require;\n\n        var output = factory.apply(exportsIndex === -1 ? envGlobal : exports, depValues);\n\n        envGlobal.require = curRequire;\n\n        if (typeof output !== 'undefined')\n          module.exports = output;\n      }\n\n      // anonymous define\n      if (!name) {\n        loader.registerDynamic(deps, false, curEsModule ? wrapEsModuleExecute(execute) : execute);\n      }\n      else {\n        loader.registerDynamic(name, deps, false, execute);\n\n        // if we don't have any other defines,\n        // then let this be an anonymous define\n        // this is just to support single modules of the form:\n        // define('jquery')\n        // still loading anonymously\n        // because it is done widely enough to be useful\n        // as soon as there is more than one define, this gets removed though\n        if (lastNamedDefine) {\n          lastNamedDefine = undefined;\n          multipleNamedDefines = true;\n        }\n        else if (!multipleNamedDefines) {\n          lastNamedDefine = [deps, execute];\n        }\n      }\n    }\n    define.amd = {};\n\n    loader.amdDefine = define;\n    loader.amdRequire = require;\n  }\n\n  // CJS\n  var windowOrigin;\n  if (typeof window !== 'undefined' && typeof document !== 'undefined' && window.location)\n    windowOrigin = location.protocol + '//' + location.hostname + (location.port ? ':' + location.port : '');\n\n  function stripOrigin(path) {\n    if (path.substr(0, 8) === 'file:///')\n      return path.substr(7 + !!isWindows);\n\n    if (windowOrigin && path.substr(0, windowOrigin.length) === windowOrigin)\n      return path.substr(windowOrigin.length);\n\n    return path;\n  }\n\n  function requireResolve (request, parentId) {\n    return stripOrigin(this.normalizeSync(request, parentId));\n  }\n\n  function getPathVars (moduleId) {\n    // remove any plugin syntax\n    var pluginIndex = moduleId.lastIndexOf('!');\n    var filename;\n    if (pluginIndex !== -1)\n      filename = moduleId.substr(0, pluginIndex);\n    else\n      filename = moduleId;\n\n    var dirname = filename.split('/');\n    dirname.pop();\n    dirname = dirname.join('/');\n\n    return {\n      filename: stripOrigin(filename),\n      dirname: stripOrigin(dirname)\n    };\n  }\n\n  var commentRegEx = /(^|[^\\\\])(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg;\n  var stringRegEx = /(\"[^\"\\\\\\n\\r]*(\\\\.[^\"\\\\\\n\\r]*)*\"|'[^'\\\\\\n\\r]*(\\\\.[^'\\\\\\n\\r]*)*')/g;\n\n  // extract CJS dependencies from source text via regex static analysis\n  // read require('x') statements not in comments or strings\n  function getCJSDeps (source) {\n    cjsRequireRegEx.lastIndex = commentRegEx.lastIndex = stringRegEx.lastIndex = 0;\n\n    var deps = [];\n\n    var match;\n\n    // track string and comment locations for unminified source\n    var stringLocations = [], commentLocations = [];\n\n    function inLocation (locations, match) {\n      for (var i = 0; i < locations.length; i++)\n        if (locations[i][0] < match.index && locations[i][1] > match.index)\n          return true;\n      return false;\n    }\n\n    if (source.length / source.split('\\n').length < 200) {\n      while (match = stringRegEx.exec(source))\n        stringLocations.push([match.index, match.index + match[0].length]);\n\n      // TODO: track template literals here before comments\n\n      while (match = commentRegEx.exec(source)) {\n        // only track comments not starting in strings\n        if (!inLocation(stringLocations, match))\n          commentLocations.push([match.index + match[1].length, match.index + match[0].length - 1]);\n      }\n    }\n\n    while (match = cjsRequireRegEx.exec(source)) {\n      // ensure we're not within a string or comment location\n      if (!inLocation(stringLocations, match) && !inLocation(commentLocations, match)) {\n        var dep = match[1].substr(1, match[1].length - 2);\n        // skip cases like require('\" + file + \"')\n        if (dep.match(/\"|'/))\n          continue;\n        deps.push(dep);\n      }\n    }\n\n    return deps;\n  }\n\n  // Global\n  // bare minimum ignores\n  var ignoredGlobalProps = ['_g', 'sessionStorage', 'localStorage', 'clipboardData', 'frames', 'frameElement', 'external',\n    'mozAnimationStartTime', 'mozPaintCount', 'webkitStorageInfo', 'webkitIndexedDB', 'mozInnerScreenY', 'mozInnerScreenX'];\n\n  var globalSnapshot;\n  function globalIterator (globalName) {\n    if (ignoredGlobalProps.indexOf(globalName) !== -1)\n      return;\n    try {\n      var value = envGlobal[globalName];\n    }\n    catch (e) {\n      ignoredGlobalProps.push(globalName);\n    }\n    this(globalName, value);\n  }\n\n  function getGlobalValue (exports) {\n    if (typeof exports === 'string')\n      return readMemberExpression(exports, envGlobal);\n\n    if (!(exports instanceof Array))\n      throw new Error('Global exports must be a string or array.');\n\n    var globalValue = {};\n    for (var i = 0; i < exports.length; i++)\n      globalValue[exports[i].split('.').pop()] = readMemberExpression(exports[i], envGlobal);\n    return globalValue;\n  }\n\n  function prepareGlobal (moduleName, exports, globals, encapsulate) {\n    // disable module detection\n    var curDefine = envGlobal.define;\n\n    envGlobal.define = undefined;\n\n    // set globals\n    var oldGlobals;\n    if (globals) {\n      oldGlobals = {};\n      for (var g in globals) {\n        oldGlobals[g] = envGlobal[g];\n        envGlobal[g] = globals[g];\n      }\n    }\n\n    // store a complete copy of the global object in order to detect changes\n    if (!exports) {\n      globalSnapshot = {};\n\n      Object.keys(envGlobal).forEach(globalIterator, function (name, value) {\n        globalSnapshot[name] = value;\n      });\n    }\n\n    // return function to retrieve global\n    return function () {\n      var globalValue = exports ? getGlobalValue(exports) : {};\n\n      var singleGlobal;\n      var multipleExports = !!exports;\n\n      if (!exports || encapsulate)\n        Object.keys(envGlobal).forEach(globalIterator, function (name, value) {\n          if (globalSnapshot[name] === value)\n            return;\n          if (value === undefined)\n            return;\n\n          // allow global encapsulation where globals are removed\n          if (encapsulate)\n            envGlobal[name] = undefined;\n\n          if (!exports) {\n            globalValue[name] = value;\n\n            if (singleGlobal !== undefined) {\n              if (!multipleExports && singleGlobal !== value)\n                multipleExports = true;\n            }\n            else {\n              singleGlobal = value;\n            }\n          }\n        });\n\n      globalValue = multipleExports ? globalValue : singleGlobal;\n\n      // revert globals\n      if (oldGlobals) {\n        for (var g in oldGlobals)\n          envGlobal[g] = oldGlobals[g];\n      }\n      envGlobal.define = curDefine;\n\n      return globalValue;\n    };\n  }\n\n  // AMD\n  var cjsRequirePre = \"(?:^|[^$_a-zA-Z\\\\xA0-\\\\uFFFF.])\";\n  var cjsRequirePost = \"\\\\s*\\\\(\\\\s*(\\\"([^\\\"]+)\\\"|'([^']+)')\\\\s*\\\\)\";\n  var fnBracketRegEx = /\\(([^\\)]*)\\)/;\n  var wsRegEx = /^\\s+|\\s+$/g;\n\n  var requireRegExs = {};\n\n  function amdGetCJSDeps(source, requireIndex) {\n\n    // remove comments\n    source = source.replace(commentRegEx, '');\n\n    // determine the require alias\n    var params = source.match(fnBracketRegEx);\n    var requireAlias = (params[1].split(',')[requireIndex] || 'require').replace(wsRegEx, '');\n\n    // find or generate the regex for this requireAlias\n    var requireRegEx = requireRegExs[requireAlias] || (requireRegExs[requireAlias] = new RegExp(cjsRequirePre + requireAlias + cjsRequirePost, 'g'));\n\n    requireRegEx.lastIndex = 0;\n\n    var deps = [];\n\n    var match;\n    while (match = requireRegEx.exec(source))\n      deps.push(match[2] || match[3]);\n\n    return deps;\n  }\n\n  function wrapEsModuleExecute (execute) {\n    return function (require, exports, module) {\n      execute(require, exports, module);\n      exports = module.exports;\n      if ((typeof exports === 'object' || typeof exports === 'function') && !('__esModule' in exports))\n        Object.defineProperty(module.exports, '__esModule', {\n          value: true\n        });\n    };\n  }\n\n  // generate anonymous define from singular named define\n  var multipleNamedDefines = false;\n  var lastNamedDefine;\n  var curMetaDeps;\n  var curEsModule = false;\n  function clearLastDefine (metaDeps, esModule) {\n    curMetaDeps = metaDeps;\n    curEsModule = esModule;\n    lastNamedDefine = undefined;\n    multipleNamedDefines = false;\n  }\n  function registerLastDefine (loader) {\n    if (lastNamedDefine)\n      loader.registerDynamic(curMetaDeps ? lastNamedDefine[0].concat(curMetaDeps) : lastNamedDefine[0],\n          false, curEsModule ? wrapEsModuleExecute(lastNamedDefine[1]) : lastNamedDefine[1]);\n\n    // bundles are an empty module\n    else if (multipleNamedDefines)\n      loader.registerDynamic([], false, noop);\n  }\n\n  var supportsScriptLoad = (isBrowser || isWorker) && typeof navigator !== 'undefined' && navigator.userAgent && !navigator.userAgent.match(/MSIE (9|10).0/);\n\n  // include the node require since we're overriding it\n  var nodeRequire;\n  if (typeof require !== 'undefined' && typeof process !== 'undefined' && !process.browser)\n    nodeRequire = require;\n\n  function setMetaEsModule (metadata, moduleValue) {\n    if (metadata.load.esModule && (typeof moduleValue === 'object' || typeof moduleValue === 'function') &&\n        !('__esModule' in moduleValue))\n      Object.defineProperty(moduleValue, '__esModule', {\n        value: true\n      });\n  }\n\n  function instantiate$1 (key, processAnonRegister) {\n    var loader = this;\n    var config = this[CONFIG];\n    // first do bundles and depCache\n    return (loadBundlesAndDepCache(config, this, key) || resolvedPromise$2)\n    .then(function () {\n      if (processAnonRegister())\n        return;\n\n      var metadata = loader[METADATA][key];\n\n      // node module loading\n      if (key.substr(0, 6) === '@node/') {\n        if (!loader._nodeRequire)\n          throw new TypeError('Error loading ' + key + '. Can only load node core modules in Node.');\n        loader.registerDynamic([], false, function () {\n          return loadNodeModule.call(loader, key.substr(6), loader.baseURL);\n        });\n        processAnonRegister();\n        return;\n      }\n\n      if (metadata.load.scriptLoad ) {\n        if (metadata.pluginKey || !supportsScriptLoad) {\n          metadata.load.scriptLoad = false;\n          warn.call(config, 'scriptLoad not supported for \"' + key + '\"');\n        }\n      }\n      else if (metadata.load.scriptLoad !== false && !metadata.pluginKey && supportsScriptLoad) {\n        // auto script load AMD, global without deps\n        if (!metadata.load.deps && !metadata.load.globals &&\n            (metadata.load.format === 'system' || metadata.load.format === 'register' || metadata.load.format === 'global' && metadata.load.exports))\n          metadata.load.scriptLoad = true;\n      }\n\n      // fetch / translate / instantiate pipeline\n      if (!metadata.load.scriptLoad)\n        return initializePlugin(loader, key, metadata)\n        .then(function () {\n          return runFetchPipeline(loader, key, metadata, processAnonRegister, config.wasm);\n        })\n\n      // just script loading\n      return new Promise(function (resolve, reject) {\n        if (metadata.load.format === 'amd' && envGlobal.define !== loader.amdDefine)\n          throw new Error('Loading AMD with scriptLoad requires setting the global `' + globalName + '.define = SystemJS.amdDefine`');\n\n        scriptLoad(key, metadata.load.crossOrigin, metadata.load.integrity, function () {\n          if (!processAnonRegister()) {\n            metadata.load.format = 'global';\n            var globalValue = metadata.load.exports && getGlobalValue(metadata.load.exports);\n            loader.registerDynamic([], false, function () {\n              setMetaEsModule(metadata, globalValue);\n              return globalValue;\n            });\n            processAnonRegister();\n          }\n\n          resolve();\n        }, reject);\n      });\n    })\n    .then(function (instantiated) {\n      delete loader[METADATA][key];\n      return instantiated;\n    });\n  }\n  function initializePlugin (loader, key, metadata) {\n    if (!metadata.pluginKey)\n      return resolvedPromise$2;\n\n    return loader.import(metadata.pluginKey).then(function (plugin) {\n      metadata.pluginModule = plugin;\n      metadata.pluginLoad = {\n        name: key,\n        address: metadata.pluginArgument,\n        source: undefined,\n        metadata: metadata.load\n      };\n      metadata.load.deps = metadata.load.deps || [];\n    });\n  }\n\n  function loadBundlesAndDepCache (config, loader, key) {\n    // load direct deps, in turn will pick up their trace trees\n    var deps;\n    if (isBrowser && (deps = config.depCache[key])) {\n      for (var i = 0; i < deps.length; i++)\n        loader.normalize(deps[i], key).then(preloadScript);\n    }\n    else {\n      var matched = false;\n      for (var b in config.bundles) {\n        for (var i = 0; i < config.bundles[b].length; i++) {\n          var curModule = config.bundles[b][i];\n\n          if (curModule === key) {\n            matched = true;\n            break;\n          }\n\n          // wildcard in bundles includes / boundaries\n          if (curModule.indexOf('*') !== -1) {\n            var parts = curModule.split('*');\n            if (parts.length !== 2) {\n              config.bundles[b].splice(i--, 1);\n              continue;\n            }\n\n            if (key.substr(0, parts[0].length) === parts[0] &&\n                key.substr(key.length - parts[1].length, parts[1].length) === parts[1]) {\n              matched = true;\n              break;\n            }\n          }\n        }\n\n        if (matched)\n          return loader.import(b);\n      }\n    }\n  }\n\n  function runFetchPipeline (loader, key, metadata, processAnonRegister, wasm) {\n    if (metadata.load.exports && !metadata.load.format)\n      metadata.load.format = 'global';\n\n    return resolvedPromise$2\n\n    // locate\n    .then(function () {\n      if (!metadata.pluginModule || !metadata.pluginModule.locate)\n        return;\n\n      return Promise.resolve(metadata.pluginModule.locate.call(loader, metadata.pluginLoad))\n      .then(function (address) {\n        if (address)\n          metadata.pluginLoad.address = address;\n      });\n    })\n\n    // fetch\n    .then(function () {\n      if (!metadata.pluginModule)\n        return fetch$1(key, metadata.load.authorization, metadata.load.integrity, wasm);\n\n      wasm = false;\n\n      if (!metadata.pluginModule.fetch)\n        return fetch$1(metadata.pluginLoad.address, metadata.load.authorization, metadata.load.integrity, false);\n\n      return metadata.pluginModule.fetch.call(loader, metadata.pluginLoad, function (load) {\n        return fetch$1(load.address, metadata.load.authorization, metadata.load.integrity, false);\n      });\n    })\n\n    .then(function (fetched) {\n      // fetch is already a utf-8 string if not doing wasm detection\n      if (!wasm || typeof fetched === 'string')\n        return translateAndInstantiate(loader, key, fetched, metadata, processAnonRegister);\n\n      return checkInstantiateWasm(loader, fetched, processAnonRegister)\n      .then(function (wasmInstantiated) {\n        if (wasmInstantiated)\n          return;\n\n        // not wasm -> convert buffer into utf-8 string to execute as a module\n        // TextDecoder compatibility matches WASM currently. Need to keep checking this.\n        // The TextDecoder interface is documented at http://encoding.spec.whatwg.org/#interface-textdecoder\n        var stringSource = isBrowser ? new TextDecoder('utf-8').decode(new Uint8Array(fetched)) : fetched.toString();\n        return translateAndInstantiate(loader, key, stringSource, metadata, processAnonRegister);\n      });\n    });\n  }\n\n  function translateAndInstantiate (loader, key, source, metadata, processAnonRegister) {\n    return Promise.resolve(source)\n    // translate\n    .then(function (source) {\n      if (metadata.load.format === 'detect')\n        metadata.load.format = undefined;\n\n      readMetaSyntax(source, metadata);\n\n      if (!metadata.pluginModule)\n        return source;\n\n      metadata.pluginLoad.source = source;\n\n      if (!metadata.pluginModule.translate)\n        return source;\n\n      return Promise.resolve(metadata.pluginModule.translate.call(loader, metadata.pluginLoad, metadata.traceOpts))\n      .then(function (translated) {\n        if (metadata.load.sourceMap) {\n          if (typeof metadata.load.sourceMap !== 'object')\n            throw new Error('metadata.load.sourceMap must be set to an object.');\n          sanitizeSourceMap(metadata.pluginLoad.address, metadata.load.sourceMap);\n        }\n\n        if (typeof translated === 'string')\n          return translated;\n        else\n          return metadata.pluginLoad.source;\n      });\n    })\n    .then(function (source) {\n      if (!metadata.load.format && source.substring(0, 8) === '\"bundle\"') {\n        metadata.load.format = 'system';\n        return source;\n      }\n\n      if (metadata.load.format === 'register' || !metadata.load.format && detectRegisterFormat(source)) {\n        metadata.load.format = 'register';\n        return source;\n      }\n\n      if (metadata.load.format !== 'esm' && (metadata.load.format || !source.match(esmRegEx))) {\n        return source;\n      }\n\n      metadata.load.format = 'esm';\n      return transpile(loader, source, key, metadata, processAnonRegister);\n    })\n\n    // instantiate\n    .then(function (translated) {\n      if (typeof translated !== 'string' || !metadata.pluginModule || !metadata.pluginModule.instantiate)\n        return translated;\n\n      var calledInstantiate = false;\n      metadata.pluginLoad.source = translated;\n      return Promise.resolve(metadata.pluginModule.instantiate.call(loader, metadata.pluginLoad, function (load) {\n        translated = load.source;\n        metadata.load = load.metadata;\n        if (calledInstantiate)\n          throw new Error('Instantiate must only be called once.');\n        calledInstantiate = true;\n      }))\n      .then(function (result) {\n        if (calledInstantiate)\n          return translated;\n        return protectedCreateNamespace(result);\n      });\n    })\n    .then(function (source) {\n      // plugin instantiate result case\n      if (typeof source !== 'string')\n        return source;\n\n      if (!metadata.load.format)\n        metadata.load.format = detectLegacyFormat(source);\n\n      var registered = false;\n\n      switch (metadata.load.format) {\n        case 'esm':\n        case 'register':\n        case 'system':\n          var err = evaluate(loader, source, metadata.load.sourceMap, key, metadata.load.integrity, metadata.load.nonce, false);\n          if (err)\n            throw err;\n          if (!processAnonRegister())\n            return emptyModule;\n          return;\n        break;\n\n        case 'json':\n          // warn.call(config, '\"json\" module format is deprecated.');\n          var parsed = JSON.parse(source);\n          return loader.newModule({ default: parsed, __useDefault: parsed });\n\n        case 'amd':\n          var curDefine = envGlobal.define;\n          envGlobal.define = loader.amdDefine;\n\n          clearLastDefine(metadata.load.deps, metadata.load.esModule);\n\n          var err = evaluate(loader, source, metadata.load.sourceMap, key, metadata.load.integrity, metadata.load.nonce, false);\n\n          // if didn't register anonymously, use the last named define if only one\n          registered = processAnonRegister();\n          if (!registered) {\n            registerLastDefine(loader);\n            registered = processAnonRegister();\n          }\n\n          envGlobal.define = curDefine;\n\n          if (err)\n            throw err;\n        break;\n\n        case 'cjs':\n          var metaDeps = metadata.load.deps;\n          var deps = (metadata.load.deps || []).concat(metadata.load.cjsRequireDetection ? getCJSDeps(source) : []);\n\n          for (var g in metadata.load.globals)\n            if (metadata.load.globals[g])\n              deps.push(metadata.load.globals[g]);\n\n          loader.registerDynamic(deps, true, function (require, exports, module) {\n            require.resolve = function (key) {\n              return requireResolve.call(loader, key, module.id);\n            };\n            // support module.paths ish\n            module.paths = [];\n            module.require = require;\n\n            // ensure meta deps execute first\n            if (!metadata.load.cjsDeferDepsExecute && metaDeps)\n              for (var i = 0; i < metaDeps.length; i++)\n                require(metaDeps[i]);\n\n            var pathVars = getPathVars(module.id);\n            var __cjsWrapper = {\n              exports: exports,\n              args: [require, exports, module, pathVars.filename, pathVars.dirname, envGlobal, envGlobal]\n            };\n\n            var cjsWrapper = \"(function (require, exports, module, __filename, __dirname, global, GLOBAL\";\n\n            // add metadata.globals to the wrapper arguments\n            if (metadata.load.globals)\n              for (var g in metadata.load.globals) {\n                __cjsWrapper.args.push(require(metadata.load.globals[g]));\n                cjsWrapper += \", \" + g;\n              }\n\n            // disable AMD detection\n            var define = envGlobal.define;\n            envGlobal.define = undefined;\n            envGlobal.__cjsWrapper = __cjsWrapper;\n\n            source = cjsWrapper + \") {\" + source.replace(hashBangRegEx$1, '') + \"\\n}).apply(__cjsWrapper.exports, __cjsWrapper.args);\";\n\n            var err = evaluate(loader, source, metadata.load.sourceMap, key, metadata.load.integrity, metadata.load.nonce, false);\n            if (err)\n              throw err;\n\n            setMetaEsModule(metadata, exports);\n\n            envGlobal.__cjsWrapper = undefined;\n            envGlobal.define = define;\n          });\n          registered = processAnonRegister();\n        break;\n\n        case 'global':\n          var deps = metadata.load.deps || [];\n          for (var g in metadata.load.globals) {\n            var gl = metadata.load.globals[g];\n            if (gl)\n              deps.push(gl);\n          }\n\n          loader.registerDynamic(deps, false, function (require, exports, module) {\n            var globals;\n            if (metadata.load.globals) {\n              globals = {};\n              for (var g in metadata.load.globals)\n                if (metadata.load.globals[g])\n                  globals[g] = require(metadata.load.globals[g]);\n            }\n\n            var exportName = metadata.load.exports;\n\n            if (exportName)\n              source += '\\n' + globalName + '[\"' + exportName + '\"] = ' + exportName + ';';\n\n            var retrieveGlobal = prepareGlobal(module.id, exportName, globals, metadata.load.encapsulateGlobal);\n            var err = evaluate(loader, source, metadata.load.sourceMap, key, metadata.load.integrity, metadata.load.nonce, true);\n\n            if (err)\n              throw err;\n\n            var output = retrieveGlobal();\n            setMetaEsModule(metadata, output);\n            return output;\n          });\n          registered = processAnonRegister();\n        break;\n\n        default:\n          throw new TypeError('Unknown module format \"' + metadata.load.format + '\" for \"' + key + '\".' + (metadata.load.format === 'es6' ? ' Use \"esm\" instead here.' : ''));\n      }\n\n      if (!registered)\n        throw new Error('Module ' + key + ' detected as ' + metadata.load.format + ' but didn\\'t execute correctly.');\n    });\n  }\n\n  var globalName = typeof self != 'undefined' ? 'self' : 'global';\n\n  // good enough ES6 module detection regex - format detections not designed to be accurate, but to handle the 99% use case\n  var esmRegEx = /(^\\s*|[}\\);\\n]\\s*)(import\\s*(['\"]|(\\*\\s+as\\s+)?(?!type)([^\"'\\(\\)\\n; ]+)\\s*from\\s*['\"]|\\{)|export\\s+\\*\\s+from\\s+[\"']|export\\s*(\\{|default|function|class|var|const|let|async\\s+function))/;\n\n  var leadingCommentAndMetaRegEx = /^(\\s*\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*\"[^\"]+\"\\s*;?|\\s*'[^']+'\\s*;?)*\\s*/;\n  function detectRegisterFormat(source) {\n    var leadingCommentAndMeta = source.match(leadingCommentAndMetaRegEx);\n    if (!leadingCommentAndMeta)\n      return false;\n    var codeStart = leadingCommentAndMeta[0].length;\n    return source.substr(codeStart, 17) === 'SystemJS.register' || source.substr(codeStart, 15) === 'System.register';\n  }\n\n  // AMD Module Format Detection RegEx\n  // define([.., .., ..], ...)\n  // define(varName); || define(function(require, exports) {}); || define({})\n  var amdRegEx = /(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])define\\s*\\(\\s*(\"[^\"]+\"\\s*,\\s*|'[^']+'\\s*,\\s*)?\\s*(\\[(\\s*((\"[^\"]+\"|'[^']+')\\s*,|\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*(\\s*(\"[^\"]+\"|'[^']+')\\s*,?)?(\\s*(\\/\\/.*\\r?\\n|\\/\\*(.|\\s)*?\\*\\/))*\\s*\\]|function\\s*|{|[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*\\))/;\n\n  /// require('...') || exports[''] = ... || exports.asd = ... || module.exports = ...\n  var cjsExportsRegEx = /(?:^\\uFEFF?|[^$_a-zA-Z\\xA0-\\uFFFF.])(exports\\s*(\\[['\"]|\\.)|module(\\.exports|\\['exports'\\]|\\[\"exports\"\\])\\s*(\\[['\"]|[=,\\.]))/;\n\n  // used to support leading #!/usr/bin/env in scripts as supported in Node\n  var hashBangRegEx$1 = /^\\#\\!.*/;\n\n  function detectLegacyFormat (source) {\n    if (source.match(amdRegEx))\n      return 'amd';\n\n    cjsExportsRegEx.lastIndex = 0;\n    cjsRequireRegEx.lastIndex = 0;\n    if (cjsRequireRegEx.exec(source) || cjsExportsRegEx.exec(source))\n      return 'cjs';\n\n    // global is the fallback format\n    return 'global';\n  }\n\n  function sanitizeSourceMap (address, sourceMap) {\n    var originalName = address.split('!')[0];\n\n    // force set the filename of the original file\n    if (!sourceMap.file || sourceMap.file == address)\n      sourceMap.file = originalName + '!transpiled';\n\n    // force set the sources list if only one source\n    if (!sourceMap.sources || sourceMap.sources.length <= 1 && (!sourceMap.sources[0] || sourceMap.sources[0] === address))\n      sourceMap.sources = [originalName];\n  }\n\n  function transpile (loader, source, key, metadata, processAnonRegister) {\n    if (!loader.transpiler)\n      throw new TypeError('Unable to dynamically transpile ES module\\n   A loader plugin needs to be configured via `SystemJS.config({ transpiler: \\'transpiler-module\\' })`.');\n\n    // deps support for es transpile\n    if (metadata.load.deps) {\n      var depsPrefix = '';\n      for (var i = 0; i < metadata.load.deps.length; i++)\n        depsPrefix += 'import \"' + metadata.load.deps[i] + '\"; ';\n      source = depsPrefix + source;\n    }\n\n    // do transpilation\n    return loader.import.call(loader, loader.transpiler)\n    .then(function (transpiler) {\n      transpiler = transpiler.__useDefault || transpiler;\n\n      // translate hooks means this is a transpiler plugin instead of a raw implementation\n      if (!transpiler.translate)\n        throw new Error(loader.transpiler + ' is not a valid transpiler plugin.');\n\n      // if transpiler is the same as the plugin loader, then don't run twice\n      if (transpiler === metadata.pluginModule)\n        return source;\n\n      // convert the source map into an object for transpilation chaining\n      if (typeof metadata.load.sourceMap === 'string')\n        metadata.load.sourceMap = JSON.parse(metadata.load.sourceMap);\n\n      metadata.pluginLoad = metadata.pluginLoad || {\n        name: key,\n        address: key,\n        source: source,\n        metadata: metadata.load\n      };\n      metadata.load.deps = metadata.load.deps || [];\n\n      return Promise.resolve(transpiler.translate.call(loader, metadata.pluginLoad, metadata.traceOpts))\n      .then(function (source) {\n        // sanitize sourceMap if an object not a JSON string\n        var sourceMap = metadata.load.sourceMap;\n        if (sourceMap && typeof sourceMap === 'object')\n          sanitizeSourceMap(key, sourceMap);\n\n        if (metadata.load.format === 'esm' && detectRegisterFormat(source))\n          metadata.load.format = 'register';\n\n        return source;\n      });\n    }, function (err) {\n      throw LoaderError__Check_error_message_for_loader_stack(err, 'Unable to load transpiler to transpile ' + key);\n    });\n  }\n\n  // detect any meta header syntax\n  // only set if not already set\n  var metaRegEx = /^(\\s*\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\s*\\/\\/[^\\n]*|\\s*\"[^\"]+\"\\s*;?|\\s*'[^']+'\\s*;?)+/;\n  var metaPartRegEx = /\\/\\*[^\\*]*(\\*(?!\\/)[^\\*]*)*\\*\\/|\\/\\/[^\\n]*|\"[^\"]+\"\\s*;?|'[^']+'\\s*;?/g;\n\n  function setMetaProperty(target, p, value) {\n    var pParts = p.split('.');\n    var curPart;\n    while (pParts.length > 1) {\n      curPart = pParts.shift();\n      target = target[curPart] = target[curPart] || {};\n    }\n    curPart = pParts.shift();\n    if (target[curPart] === undefined)\n      target[curPart] = value;\n  }\n\n  function readMetaSyntax (source, metadata) {\n    var meta = source.match(metaRegEx);\n    if (!meta)\n      return;\n\n    var metaParts = meta[0].match(metaPartRegEx);\n\n    for (var i = 0; i < metaParts.length; i++) {\n      var curPart = metaParts[i];\n      var len = curPart.length;\n\n      var firstChar = curPart.substr(0, 1);\n      if (curPart.substr(len - 1, 1) == ';')\n        len--;\n\n      if (firstChar != '\"' && firstChar != \"'\")\n        continue;\n\n      var metaString = curPart.substr(1, curPart.length - 3);\n      var metaName = metaString.substr(0, metaString.indexOf(' '));\n\n      if (metaName) {\n        var metaValue = metaString.substr(metaName.length + 1, metaString.length - metaName.length - 1);\n\n        if (metaName === 'deps')\n          metaName = 'deps[]';\n\n        if (metaName.substr(metaName.length - 2, 2) === '[]') {\n          metaName = metaName.substr(0, metaName.length - 2);\n          metadata.load[metaName] = metadata.load[metaName] || [];\n          metadata.load[metaName].push(metaValue);\n        }\n        // \"use strict\" is not meta\n        else if (metaName !== 'use') {\n          setMetaProperty(metadata.load, metaName, metaValue);\n        }\n      }\n      else {\n        metadata.load[metaString] = true;\n      }\n    }\n  }\n\n  var scriptSrc;\n\n  // Promise detection and error message\n  if (typeof Promise === 'undefined')\n    throw new Error('SystemJS needs a Promise polyfill.');\n\n  if (typeof document !== 'undefined') {\n    var scripts = document.getElementsByTagName('script');\n    var curScript = scripts[scripts.length - 1];\n    if (document.currentScript && (curScript.defer || curScript.async))\n      curScript = document.currentScript;\n\n    scriptSrc = curScript && curScript.src;\n  }\n  // worker\n  else if (typeof importScripts !== 'undefined') {\n    try {\n      throw new Error('_');\n    }\n    catch (e) {\n      e.stack.replace(/(?:at|@).*(http.+):[\\d]+:[\\d]+/, function(m, url) {\n        scriptSrc = url;\n      });\n    }\n  }\n  // node\n  else if (typeof __filename !== 'undefined') {\n    scriptSrc = __filename;\n  }\n\n  function SystemJSLoader () {\n    RegisterLoader.call(this);\n\n    // NB deprecate\n    this._loader = {};\n\n    // internal metadata store\n    this[METADATA] = {};\n\n    // internal configuration\n    this[CONFIG] = {\n      baseURL: baseURI,\n      paths: {},\n\n      packageConfigPaths: [],\n      packageConfigKeys: [],\n      map: {},\n      packages: {},\n      depCache: {},\n      meta: {},\n      bundles: {},\n\n      production: false,\n\n      transpiler: undefined,\n      loadedBundles: {},\n\n      // global behaviour flags\n      warnings: false,\n      pluginFirst: false,\n\n      // enable wasm loading and detection when supported\n      wasm: false\n    };\n\n    // make the location of the system.js script accessible (if any)\n    this.scriptSrc = scriptSrc;\n\n    this._nodeRequire = nodeRequire;\n\n    // support the empty module, as a concept\n    this.registry.set('@empty', emptyModule);\n\n    setProduction.call(this, false, false);\n\n    // add module format helpers\n    setHelpers(this);\n    setAmdHelper(this);\n  }\n\n  var envModule;\n  function setProduction (isProduction, isBuilder) {\n    this[CONFIG].production = isProduction;\n    this.registry.set('@system-env', envModule = this.newModule({\n      browser: isBrowser,\n      node: !!this._nodeRequire,\n      production: !isBuilder && isProduction,\n      dev: isBuilder || !isProduction,\n      build: isBuilder,\n      'default': true\n    }));\n  }\n\n  SystemJSLoader.prototype = Object.create(RegisterLoader.prototype);\n\n  SystemJSLoader.prototype.constructor = SystemJSLoader;\n\n  // NB deprecate normalize\n  SystemJSLoader.prototype[SystemJSLoader.resolve = RegisterLoader.resolve] = SystemJSLoader.prototype.normalize = normalize;\n\n  SystemJSLoader.prototype.load = function (key, parentKey) {\n    warn.call(this[CONFIG], 'System.load is deprecated.');\n    return this.import(key, parentKey);\n  };\n\n  // NB deprecate decanonicalize, normalizeSync\n  SystemJSLoader.prototype.decanonicalize = SystemJSLoader.prototype.normalizeSync = SystemJSLoader.prototype.resolveSync = normalizeSync;\n\n  SystemJSLoader.prototype[SystemJSLoader.instantiate = RegisterLoader.instantiate] = instantiate$1;\n\n  SystemJSLoader.prototype.config = setConfig;\n  SystemJSLoader.prototype.getConfig = getConfig;\n\n  SystemJSLoader.prototype.global = envGlobal;\n\n  SystemJSLoader.prototype.import = function () {\n    return RegisterLoader.prototype.import.apply(this, arguments)\n    .then(function (m) {\n      return '__useDefault' in m ? m.__useDefault : m;\n    });\n  };\n\n  var configNames = ['baseURL', 'map', 'paths', 'packages', 'packageConfigPaths', 'depCache', 'meta', 'bundles', 'transpiler', 'warnings', 'pluginFirst', 'production', 'wasm'];\n\n  var hasProxy = typeof Proxy !== 'undefined';\n  for (var i = 0; i < configNames.length; i++) (function (configName) {\n    Object.defineProperty(SystemJSLoader.prototype, configName, {\n      get: function () {\n        var cfg = getConfigItem(this[CONFIG], configName);\n\n        if (hasProxy && typeof cfg === 'object')\n          cfg = new Proxy(cfg, {\n            set: function (target, option) {\n              throw new Error('Cannot set SystemJS.' + configName + '[\"' + option + '\"] directly. Use SystemJS.config({ ' + configName + ': { \"' + option + '\": ... } }) rather.');\n            }\n          });\n\n        //if (typeof cfg === 'object')\n        //  warn.call(this[CONFIG], 'Referencing `SystemJS.' + configName + '` is deprecated. Use the config getter `SystemJS.getConfig(\\'' + configName + '\\')`');\n        return cfg;\n      },\n      set: function (name) {\n        throw new Error('Setting `SystemJS.' + configName + '` directly is no longer supported. Use `SystemJS.config({ ' + configName + ': ... })`.');\n      }\n    });\n  })(configNames[i]);\n\n  /*\n   * Backwards-compatible registry API, to be deprecated\n   */\n  function registryWarn(loader, method) {\n    warn.call(loader[CONFIG], 'SystemJS.' + method + ' is deprecated for SystemJS.registry.' + method);\n  }\n  SystemJSLoader.prototype.delete = function (key) {\n    registryWarn(this, 'delete');\n    return this.registry.delete(key);\n  };\n  SystemJSLoader.prototype.get = function (key) {\n    registryWarn(this, 'get');\n    return this.registry.get(key);\n  };\n  SystemJSLoader.prototype.has = function (key) {\n    registryWarn(this, 'has');\n    return this.registry.has(key);\n  };\n  SystemJSLoader.prototype.set = function (key, module) {\n    registryWarn(this, 'set');\n    return this.registry.set(key, module);\n  };\n  SystemJSLoader.prototype.newModule = function (bindings) {\n    return new ModuleNamespace(bindings);\n  };\n  SystemJSLoader.prototype.isModule = isModule;\n\n  // ensure System.register and System.registerDynamic decanonicalize\n  SystemJSLoader.prototype.register = function (key, deps, declare) {\n    if (typeof key === 'string')\n      key = decanonicalize.call(this, this[CONFIG], key);\n    return RegisterLoader.prototype.register.call(this, key, deps, declare);\n  };\n\n  SystemJSLoader.prototype.registerDynamic = function (key, deps, executingRequire, execute) {\n    if (typeof key === 'string')\n      key = decanonicalize.call(this, this[CONFIG], key);\n    return RegisterLoader.prototype.registerDynamic.call(this, key, deps, executingRequire, execute);\n  };\n\n  SystemJSLoader.prototype.version = \"0.21.6 Dev\";\n\n  var System = new SystemJSLoader();\n\n  // only set the global System on the global in browsers\n  if (isBrowser || isWorker)\n    envGlobal.SystemJS = envGlobal.System = System;\n\n  if (typeof module !== 'undefined' && module.exports)\n    module.exports = System;\n\n}());\n//# sourceMappingURL=system.src.js.map\n"],"sourceRoot":"webpack:///"}